// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "larpc.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>

namespace larpc {

namespace {

const ::google::protobuf::Descriptor* EncryptionDescriptor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EncryptionDescriptor_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeygenParameters_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeygenParameters_reflection_ = NULL;
const ::google::protobuf::Descriptor* MachineKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MachineKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* Config_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Config_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChannelMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChannelMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChannelSetup_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChannelSetup_reflection_ = NULL;
const ::google::protobuf::Descriptor* PrincipleVersionRecord_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PrincipleVersionRecord_reflection_ = NULL;
const ::google::protobuf::Descriptor* PrincipleDescriptor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PrincipleDescriptor_reflection_ = NULL;
const ::google::protobuf::Descriptor* MethodDescriptor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MethodDescriptor_reflection_ = NULL;
const ::google::protobuf::Descriptor* RPCRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RPCRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* RPCResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RPCResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* OpenChannelRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OpenChannelRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* OpenChannelResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OpenChannelResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChannelControl_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChannelControl_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_larpc_2eproto() {
  protobuf_AddDesc_larpc_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "larpc.proto");
  GOOGLE_CHECK(file != NULL);
  EncryptionDescriptor_descriptor_ = file->message_type(0);
  static const int EncryptionDescriptor_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptionDescriptor, cipher_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptionDescriptor, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptionDescriptor, iv_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptionDescriptor, is_password_based_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptionDescriptor, password_digest_algorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptionDescriptor, key_hash_),
  };
  EncryptionDescriptor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EncryptionDescriptor_descriptor_,
      EncryptionDescriptor::default_instance_,
      EncryptionDescriptor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptionDescriptor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptionDescriptor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EncryptionDescriptor));
  KeygenParameters_descriptor_ = file->message_type(1);
  static const int KeygenParameters_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeygenParameters, key_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeygenParameters, num_bits_),
  };
  KeygenParameters_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeygenParameters_descriptor_,
      KeygenParameters::default_instance_,
      KeygenParameters_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeygenParameters, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeygenParameters, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeygenParameters));
  MachineKey_descriptor_ = file->message_type(2);
  static const int MachineKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineKey, public_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineKey, private_key_),
  };
  MachineKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MachineKey_descriptor_,
      MachineKey::default_instance_,
      MachineKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MachineKey));
  Config_descriptor_ = file->message_type(3);
  static const int Config_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, machine_key_file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, machine_key_encryption_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, local_principles_file_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, bind_ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, bind_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, trust_certificate_issuer_cn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, trust_certificate_expiration_time_days_),
  };
  Config_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Config_descriptor_,
      Config::default_instance_,
      Config_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Config, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Config));
  ChannelMessage_descriptor_ = file->message_type(4);
  static const int ChannelMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelMessage, requests_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelMessage, responses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelMessage, control_),
  };
  ChannelMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChannelMessage_descriptor_,
      ChannelMessage::default_instance_,
      ChannelMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChannelMessage));
  ChannelSetup_descriptor_ = file->message_type(5);
  static const int ChannelSetup_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelSetup, machine_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelSetup, principles_),
  };
  ChannelSetup_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChannelSetup_descriptor_,
      ChannelSetup::default_instance_,
      ChannelSetup_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelSetup, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelSetup, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChannelSetup));
  PrincipleVersionRecord_descriptor_ = file->message_type(6);
  static const int PrincipleVersionRecord_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleVersionRecord, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleVersionRecord, hash_),
  };
  PrincipleVersionRecord_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PrincipleVersionRecord_descriptor_,
      PrincipleVersionRecord::default_instance_,
      PrincipleVersionRecord_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleVersionRecord, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleVersionRecord, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PrincipleVersionRecord));
  PrincipleDescriptor_descriptor_ = file->message_type(7);
  static const int PrincipleDescriptor_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleDescriptor, display_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleDescriptor, public_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleDescriptor, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleDescriptor, trusting_x509_certificate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleDescriptor, encrypted_private_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleDescriptor, private_key_encryption_descriptor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleDescriptor, past_versions_),
  };
  PrincipleDescriptor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PrincipleDescriptor_descriptor_,
      PrincipleDescriptor::default_instance_,
      PrincipleDescriptor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleDescriptor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PrincipleDescriptor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PrincipleDescriptor));
  MethodDescriptor_descriptor_ = file->message_type(8);
  static const int MethodDescriptor_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MethodDescriptor, method_name_),
  };
  MethodDescriptor_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MethodDescriptor_descriptor_,
      MethodDescriptor::default_instance_,
      MethodDescriptor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MethodDescriptor, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MethodDescriptor, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MethodDescriptor));
  RPCRequest_descriptor_ = file->message_type(9);
  static const int RPCRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCRequest, channel_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCRequest, request_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCRequest, method_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCRequest, method_parameters_),
  };
  RPCRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RPCRequest_descriptor_,
      RPCRequest::default_instance_,
      RPCRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RPCRequest));
  RPCResponse_descriptor_ = file->message_type(10);
  static const int RPCResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCResponse, channel_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCResponse, request_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCResponse, response_),
  };
  RPCResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RPCResponse_descriptor_,
      RPCResponse::default_instance_,
      RPCResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RPCResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RPCResponse));
  OpenChannelRequest_descriptor_ = file->message_type(11);
  static const int OpenChannelRequest_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelRequest, initiator_public_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelRequest, initiator_certificate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelRequest, desired_principle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelRequest, channel_id_),
  };
  OpenChannelRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OpenChannelRequest_descriptor_,
      OpenChannelRequest::default_instance_,
      OpenChannelRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OpenChannelRequest));
  OpenChannelResponse_descriptor_ = file->message_type(12);
  static const int OpenChannelResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelResponse, initiator_channel_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelResponse, responding_channel_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelResponse, responding_certificate_),
  };
  OpenChannelResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OpenChannelResponse_descriptor_,
      OpenChannelResponse::default_instance_,
      OpenChannelResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OpenChannelResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OpenChannelResponse));
  ChannelControl_descriptor_ = file->message_type(13);
  static const int ChannelControl_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelControl, open_channel_request_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelControl, open_channel_response_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelControl, close_channel_id_),
  };
  ChannelControl_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChannelControl_descriptor_,
      ChannelControl::default_instance_,
      ChannelControl_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelControl, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChannelControl, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChannelControl));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_larpc_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EncryptionDescriptor_descriptor_, &EncryptionDescriptor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeygenParameters_descriptor_, &KeygenParameters::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MachineKey_descriptor_, &MachineKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Config_descriptor_, &Config::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChannelMessage_descriptor_, &ChannelMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChannelSetup_descriptor_, &ChannelSetup::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PrincipleVersionRecord_descriptor_, &PrincipleVersionRecord::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PrincipleDescriptor_descriptor_, &PrincipleDescriptor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MethodDescriptor_descriptor_, &MethodDescriptor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RPCRequest_descriptor_, &RPCRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RPCResponse_descriptor_, &RPCResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OpenChannelRequest_descriptor_, &OpenChannelRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OpenChannelResponse_descriptor_, &OpenChannelResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChannelControl_descriptor_, &ChannelControl::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_larpc_2eproto() {
  delete EncryptionDescriptor::default_instance_;
  delete EncryptionDescriptor_reflection_;
  delete KeygenParameters::default_instance_;
  delete KeygenParameters_reflection_;
  delete MachineKey::default_instance_;
  delete MachineKey_reflection_;
  delete Config::default_instance_;
  delete Config_reflection_;
  delete ChannelMessage::default_instance_;
  delete ChannelMessage_reflection_;
  delete ChannelSetup::default_instance_;
  delete ChannelSetup_reflection_;
  delete PrincipleVersionRecord::default_instance_;
  delete PrincipleVersionRecord_reflection_;
  delete PrincipleDescriptor::default_instance_;
  delete PrincipleDescriptor_reflection_;
  delete MethodDescriptor::default_instance_;
  delete MethodDescriptor_reflection_;
  delete RPCRequest::default_instance_;
  delete RPCRequest_reflection_;
  delete RPCResponse::default_instance_;
  delete RPCResponse_reflection_;
  delete OpenChannelRequest::default_instance_;
  delete OpenChannelRequest_reflection_;
  delete OpenChannelResponse::default_instance_;
  delete OpenChannelResponse_reflection_;
  delete ChannelControl::default_instance_;
  delete ChannelControl_reflection_;
}

void protobuf_AddDesc_larpc_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013larpc.proto\022\005larpc\"\226\001\n\024EncryptionDescr"
    "iptor\022\016\n\006cipher\030\001 \001(\t\022\013\n\003key\030\002 \001(\t\022\n\n\002iv"
    "\030\003 \001(\t\022 \n\021is_password_based\030\004 \001(\010:\005false"
    "\022!\n\031password_digest_algorithm\030\005 \001(\t\022\020\n\010k"
    "ey_hash\030\006 \001(\t\"6\n\020KeygenParameters\022\020\n\010key"
    "_type\030\001 \002(\t\022\020\n\010num_bits\030\002 \001(\r\"5\n\nMachine"
    "Key\022\022\n\npublic_key\030\001 \002(\t\022\023\n\013private_key\030\002"
    " \002(\t\"\367\001\n\006Config\022\030\n\020machine_key_file\030\001 \002("
    "\t\022;\n\026machine_key_encryption\030\002 \001(\0132\033.larp"
    "c.EncryptionDescriptor\022\035\n\025local_principl"
    "es_file\030\003 \002(\t\022\017\n\007bind_ip\030\004 \002(\t\022\021\n\tbind_p"
    "ort\030\005 \002(\005\022#\n\033trust_certificate_issuer_cn"
    "\030\006 \002(\t\022.\n&trust_certificate_expiration_t"
    "ime_days\030\007 \002(\005\"\204\001\n\016ChannelMessage\022#\n\010req"
    "uests\030\001 \003(\0132\021.larpc.RPCRequest\022%\n\trespon"
    "ses\030\002 \003(\0132\022.larpc.RPCResponse\022&\n\007control"
    "\030\003 \001(\0132\025.larpc.ChannelControl\"R\n\014Channel"
    "Setup\022\022\n\nmachine_id\030\001 \002(\t\022.\n\nprinciples\030"
    "\002 \003(\0132\032.larpc.PrincipleDescriptor\"7\n\026Pri"
    "ncipleVersionRecord\022\017\n\007version\030\001 \002(\r\022\014\n\004"
    "hash\030\002 \002(\t\"\220\002\n\023PrincipleDescriptor\022\024\n\014di"
    "splay_name\030\001 \002(\t\022\022\n\npublic_key\030\002 \002(\t\022\017\n\007"
    "version\030\003 \002(\r\022!\n\031trusting_x509_certifica"
    "te\030\004 \003(\t\022\035\n\025encrypted_private_key\030\006 \001(\t\022"
    "F\n!private_key_encryption_descriptor\030\007 \001"
    "(\0132\033.larpc.EncryptionDescriptor\0224\n\rpast_"
    "versions\030\010 \003(\0132\035.larpc.PrincipleVersionR"
    "ecord\"\'\n\020MethodDescriptor\022\023\n\013method_name"
    "\030\001 \001(\t\"{\n\nRPCRequest\022\022\n\nchannel_id\030\001 \001(\t"
    "\022\022\n\nrequest_id\030\002 \001(\r\022*\n\tmethod_id\030\003 \001(\0132"
    "\027.larpc.MethodDescriptor\022\031\n\021method_param"
    "eters\030\004 \001(\014\"G\n\013RPCResponse\022\022\n\nchannel_id"
    "\030\001 \001(\t\022\022\n\nrequest_id\030\002 \001(\r\022\020\n\010response\030\003"
    " \001(\014\"\234\001\n\022OpenChannelRequest\022\034\n\024initiator"
    "_public_key\030\001 \001(\014\022\035\n\025initiator_certifica"
    "te\030\002 \001(\014\0225\n\021desired_principle\030\003 \001(\0132\032.la"
    "rpc.PrincipleDescriptor\022\022\n\nchannel_id\030\004 "
    "\001(\t\"r\n\023OpenChannelResponse\022\034\n\024initiator_"
    "channel_id\030\001 \001(\t\022\035\n\025responding_channel_i"
    "d\030\002 \001(\t\022\036\n\026responding_certificate\030\003 \001(\014\""
    "\236\001\n\016ChannelControl\0227\n\024open_channel_reque"
    "st\030\001 \003(\0132\031.larpc.OpenChannelRequest\0229\n\025o"
    "pen_channel_response\030\002 \003(\0132\032.larpc.OpenC"
    "hannelResponse\022\030\n\020close_channel_id\030\003 \003(\t", 1760);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "larpc.proto", &protobuf_RegisterTypes);
  EncryptionDescriptor::default_instance_ = new EncryptionDescriptor();
  KeygenParameters::default_instance_ = new KeygenParameters();
  MachineKey::default_instance_ = new MachineKey();
  Config::default_instance_ = new Config();
  ChannelMessage::default_instance_ = new ChannelMessage();
  ChannelSetup::default_instance_ = new ChannelSetup();
  PrincipleVersionRecord::default_instance_ = new PrincipleVersionRecord();
  PrincipleDescriptor::default_instance_ = new PrincipleDescriptor();
  MethodDescriptor::default_instance_ = new MethodDescriptor();
  RPCRequest::default_instance_ = new RPCRequest();
  RPCResponse::default_instance_ = new RPCResponse();
  OpenChannelRequest::default_instance_ = new OpenChannelRequest();
  OpenChannelResponse::default_instance_ = new OpenChannelResponse();
  ChannelControl::default_instance_ = new ChannelControl();
  EncryptionDescriptor::default_instance_->InitAsDefaultInstance();
  KeygenParameters::default_instance_->InitAsDefaultInstance();
  MachineKey::default_instance_->InitAsDefaultInstance();
  Config::default_instance_->InitAsDefaultInstance();
  ChannelMessage::default_instance_->InitAsDefaultInstance();
  ChannelSetup::default_instance_->InitAsDefaultInstance();
  PrincipleVersionRecord::default_instance_->InitAsDefaultInstance();
  PrincipleDescriptor::default_instance_->InitAsDefaultInstance();
  MethodDescriptor::default_instance_->InitAsDefaultInstance();
  RPCRequest::default_instance_->InitAsDefaultInstance();
  RPCResponse::default_instance_->InitAsDefaultInstance();
  OpenChannelRequest::default_instance_->InitAsDefaultInstance();
  OpenChannelResponse::default_instance_->InitAsDefaultInstance();
  ChannelControl::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_larpc_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_larpc_2eproto {
  StaticDescriptorInitializer_larpc_2eproto() {
    protobuf_AddDesc_larpc_2eproto();
  }
} static_descriptor_initializer_larpc_2eproto_;


// ===================================================================

const ::std::string EncryptionDescriptor::_default_cipher_;
const ::std::string EncryptionDescriptor::_default_key_;
const ::std::string EncryptionDescriptor::_default_iv_;
const ::std::string EncryptionDescriptor::_default_password_digest_algorithm_;
const ::std::string EncryptionDescriptor::_default_key_hash_;
#ifndef _MSC_VER
const int EncryptionDescriptor::kCipherFieldNumber;
const int EncryptionDescriptor::kKeyFieldNumber;
const int EncryptionDescriptor::kIvFieldNumber;
const int EncryptionDescriptor::kIsPasswordBasedFieldNumber;
const int EncryptionDescriptor::kPasswordDigestAlgorithmFieldNumber;
const int EncryptionDescriptor::kKeyHashFieldNumber;
#endif  // !_MSC_VER

EncryptionDescriptor::EncryptionDescriptor() {
  SharedCtor();
}

void EncryptionDescriptor::InitAsDefaultInstance() {
}

EncryptionDescriptor::EncryptionDescriptor(const EncryptionDescriptor& from) {
  SharedCtor();
  MergeFrom(from);
}

void EncryptionDescriptor::SharedCtor() {
  _cached_size_ = 0;
  cipher_ = const_cast< ::std::string*>(&_default_cipher_);
  key_ = const_cast< ::std::string*>(&_default_key_);
  iv_ = const_cast< ::std::string*>(&_default_iv_);
  is_password_based_ = false;
  password_digest_algorithm_ = const_cast< ::std::string*>(&_default_password_digest_algorithm_);
  key_hash_ = const_cast< ::std::string*>(&_default_key_hash_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EncryptionDescriptor::~EncryptionDescriptor() {
  SharedDtor();
}

void EncryptionDescriptor::SharedDtor() {
  if (cipher_ != &_default_cipher_) {
    delete cipher_;
  }
  if (key_ != &_default_key_) {
    delete key_;
  }
  if (iv_ != &_default_iv_) {
    delete iv_;
  }
  if (password_digest_algorithm_ != &_default_password_digest_algorithm_) {
    delete password_digest_algorithm_;
  }
  if (key_hash_ != &_default_key_hash_) {
    delete key_hash_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* EncryptionDescriptor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EncryptionDescriptor_descriptor_;
}

const EncryptionDescriptor& EncryptionDescriptor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

EncryptionDescriptor* EncryptionDescriptor::default_instance_ = NULL;

EncryptionDescriptor* EncryptionDescriptor::New() const {
  return new EncryptionDescriptor;
}

void EncryptionDescriptor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (cipher_ != &_default_cipher_) {
        cipher_->clear();
      }
    }
    if (_has_bit(1)) {
      if (key_ != &_default_key_) {
        key_->clear();
      }
    }
    if (_has_bit(2)) {
      if (iv_ != &_default_iv_) {
        iv_->clear();
      }
    }
    is_password_based_ = false;
    if (_has_bit(4)) {
      if (password_digest_algorithm_ != &_default_password_digest_algorithm_) {
        password_digest_algorithm_->clear();
      }
    }
    if (_has_bit(5)) {
      if (key_hash_ != &_default_key_hash_) {
        key_hash_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EncryptionDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string cipher = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_cipher()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->cipher().data(), this->cipher().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }
      
      // optional string key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_key:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_key()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->key().data(), this->key().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(26)) goto parse_iv;
        break;
      }
      
      // optional string iv = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_iv:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_iv()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->iv().data(), this->iv().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(32)) goto parse_is_password_based;
        break;
      }
      
      // optional bool is_password_based = 4 [default = false];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_is_password_based:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBool(
              input, &is_password_based_));
        _set_bit(3);
        if (input->ExpectTag(42)) goto parse_password_digest_algorithm;
        break;
      }
      
      // optional string password_digest_algorithm = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_password_digest_algorithm:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_password_digest_algorithm()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->password_digest_algorithm().data(), this->password_digest_algorithm().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(50)) goto parse_key_hash;
        break;
      }
      
      // optional string key_hash = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_key_hash:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_key_hash()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->key_hash().data(), this->key_hash().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EncryptionDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    EncryptionDescriptor::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional string cipher = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cipher().data(), this->cipher().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->cipher(), output);
  }
  
  // optional string key = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->key(), output);
  }
  
  // optional string iv = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->iv().data(), this->iv().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->iv(), output);
  }
  
  // optional bool is_password_based = 4 [default = false];
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->is_password_based(), output);
  }
  
  // optional string password_digest_algorithm = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->password_digest_algorithm().data(), this->password_digest_algorithm().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->password_digest_algorithm(), output);
  }
  
  // optional string key_hash = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key_hash().data(), this->key_hash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->key_hash(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EncryptionDescriptor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string cipher = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cipher().data(), this->cipher().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->cipher(), target);
  }
  
  // optional string key = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->key(), target);
  }
  
  // optional string iv = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->iv().data(), this->iv().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->iv(), target);
  }
  
  // optional bool is_password_based = 4 [default = false];
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->is_password_based(), target);
  }
  
  // optional string password_digest_algorithm = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->password_digest_algorithm().data(), this->password_digest_algorithm().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->password_digest_algorithm(), target);
  }
  
  // optional string key_hash = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key_hash().data(), this->key_hash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->key_hash(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EncryptionDescriptor::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string cipher = 1;
    if (has_cipher()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cipher());
    }
    
    // optional string key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }
    
    // optional string iv = 3;
    if (has_iv()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->iv());
    }
    
    // optional bool is_password_based = 4 [default = false];
    if (has_is_password_based()) {
      total_size += 1 + 1;
    }
    
    // optional string password_digest_algorithm = 5;
    if (has_password_digest_algorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->password_digest_algorithm());
    }
    
    // optional string key_hash = 6;
    if (has_key_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key_hash());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void EncryptionDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EncryptionDescriptor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EncryptionDescriptor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EncryptionDescriptor::MergeFrom(const EncryptionDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_cipher(from.cipher());
    }
    if (from._has_bit(1)) {
      set_key(from.key());
    }
    if (from._has_bit(2)) {
      set_iv(from.iv());
    }
    if (from._has_bit(3)) {
      set_is_password_based(from.is_password_based());
    }
    if (from._has_bit(4)) {
      set_password_digest_algorithm(from.password_digest_algorithm());
    }
    if (from._has_bit(5)) {
      set_key_hash(from.key_hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EncryptionDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EncryptionDescriptor::CopyFrom(const EncryptionDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptionDescriptor::IsInitialized() const {
  
  return true;
}

void EncryptionDescriptor::Swap(EncryptionDescriptor* other) {
  if (other != this) {
    std::swap(cipher_, other->cipher_);
    std::swap(key_, other->key_);
    std::swap(iv_, other->iv_);
    std::swap(is_password_based_, other->is_password_based_);
    std::swap(password_digest_algorithm_, other->password_digest_algorithm_);
    std::swap(key_hash_, other->key_hash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EncryptionDescriptor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EncryptionDescriptor_descriptor_;
  metadata.reflection = EncryptionDescriptor_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string KeygenParameters::_default_key_type_;
#ifndef _MSC_VER
const int KeygenParameters::kKeyTypeFieldNumber;
const int KeygenParameters::kNumBitsFieldNumber;
#endif  // !_MSC_VER

KeygenParameters::KeygenParameters() {
  SharedCtor();
}

void KeygenParameters::InitAsDefaultInstance() {
}

KeygenParameters::KeygenParameters(const KeygenParameters& from) {
  SharedCtor();
  MergeFrom(from);
}

void KeygenParameters::SharedCtor() {
  _cached_size_ = 0;
  key_type_ = const_cast< ::std::string*>(&_default_key_type_);
  num_bits_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeygenParameters::~KeygenParameters() {
  SharedDtor();
}

void KeygenParameters::SharedDtor() {
  if (key_type_ != &_default_key_type_) {
    delete key_type_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* KeygenParameters::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeygenParameters_descriptor_;
}

const KeygenParameters& KeygenParameters::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

KeygenParameters* KeygenParameters::default_instance_ = NULL;

KeygenParameters* KeygenParameters::New() const {
  return new KeygenParameters;
}

void KeygenParameters::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (key_type_ != &_default_key_type_) {
        key_type_->clear();
      }
    }
    num_bits_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeygenParameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_key_type()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->key_type().data(), this->key_type().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(16)) goto parse_num_bits;
        break;
      }
      
      // optional uint32 num_bits = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_num_bits:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &num_bits_));
        _set_bit(1);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeygenParameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    KeygenParameters::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string key_type = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key_type().data(), this->key_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key_type(), output);
  }
  
  // optional uint32 num_bits = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->num_bits(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeygenParameters::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string key_type = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key_type().data(), this->key_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key_type(), target);
  }
  
  // optional uint32 num_bits = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->num_bits(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeygenParameters::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string key_type = 1;
    if (has_key_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key_type());
    }
    
    // optional uint32 num_bits = 2;
    if (has_num_bits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->num_bits());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void KeygenParameters::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeygenParameters* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeygenParameters*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeygenParameters::MergeFrom(const KeygenParameters& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_key_type(from.key_type());
    }
    if (from._has_bit(1)) {
      set_num_bits(from.num_bits());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeygenParameters::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeygenParameters::CopyFrom(const KeygenParameters& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeygenParameters::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

void KeygenParameters::Swap(KeygenParameters* other) {
  if (other != this) {
    std::swap(key_type_, other->key_type_);
    std::swap(num_bits_, other->num_bits_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeygenParameters::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeygenParameters_descriptor_;
  metadata.reflection = KeygenParameters_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string MachineKey::_default_public_key_;
const ::std::string MachineKey::_default_private_key_;
#ifndef _MSC_VER
const int MachineKey::kPublicKeyFieldNumber;
const int MachineKey::kPrivateKeyFieldNumber;
#endif  // !_MSC_VER

MachineKey::MachineKey() {
  SharedCtor();
}

void MachineKey::InitAsDefaultInstance() {
}

MachineKey::MachineKey(const MachineKey& from) {
  SharedCtor();
  MergeFrom(from);
}

void MachineKey::SharedCtor() {
  _cached_size_ = 0;
  public_key_ = const_cast< ::std::string*>(&_default_public_key_);
  private_key_ = const_cast< ::std::string*>(&_default_private_key_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MachineKey::~MachineKey() {
  SharedDtor();
}

void MachineKey::SharedDtor() {
  if (public_key_ != &_default_public_key_) {
    delete public_key_;
  }
  if (private_key_ != &_default_private_key_) {
    delete private_key_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* MachineKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MachineKey_descriptor_;
}

const MachineKey& MachineKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

MachineKey* MachineKey::default_instance_ = NULL;

MachineKey* MachineKey::New() const {
  return new MachineKey;
}

void MachineKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (public_key_ != &_default_public_key_) {
        public_key_->clear();
      }
    }
    if (_has_bit(1)) {
      if (private_key_ != &_default_private_key_) {
        private_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MachineKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string public_key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_public_key()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->public_key().data(), this->public_key().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_private_key;
        break;
      }
      
      // required string private_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_private_key:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_private_key()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->private_key().data(), this->private_key().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MachineKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    MachineKey::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string public_key = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_key().data(), this->public_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->public_key(), output);
  }
  
  // required string private_key = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->private_key().data(), this->private_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->private_key(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MachineKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string public_key = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_key().data(), this->public_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->public_key(), target);
  }
  
  // required string private_key = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->private_key().data(), this->private_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->private_key(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MachineKey::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string public_key = 1;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->public_key());
    }
    
    // required string private_key = 2;
    if (has_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->private_key());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void MachineKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MachineKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MachineKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MachineKey::MergeFrom(const MachineKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_public_key(from.public_key());
    }
    if (from._has_bit(1)) {
      set_private_key(from.private_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MachineKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MachineKey::CopyFrom(const MachineKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MachineKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void MachineKey::Swap(MachineKey* other) {
  if (other != this) {
    std::swap(public_key_, other->public_key_);
    std::swap(private_key_, other->private_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MachineKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MachineKey_descriptor_;
  metadata.reflection = MachineKey_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string Config::_default_machine_key_file_;
const ::std::string Config::_default_local_principles_file_;
const ::std::string Config::_default_bind_ip_;
const ::std::string Config::_default_trust_certificate_issuer_cn_;
#ifndef _MSC_VER
const int Config::kMachineKeyFileFieldNumber;
const int Config::kMachineKeyEncryptionFieldNumber;
const int Config::kLocalPrinciplesFileFieldNumber;
const int Config::kBindIpFieldNumber;
const int Config::kBindPortFieldNumber;
const int Config::kTrustCertificateIssuerCnFieldNumber;
const int Config::kTrustCertificateExpirationTimeDaysFieldNumber;
#endif  // !_MSC_VER

Config::Config() {
  SharedCtor();
}

void Config::InitAsDefaultInstance() {
  machine_key_encryption_ = const_cast< ::larpc::EncryptionDescriptor*>(&::larpc::EncryptionDescriptor::default_instance());
}

Config::Config(const Config& from) {
  SharedCtor();
  MergeFrom(from);
}

void Config::SharedCtor() {
  _cached_size_ = 0;
  machine_key_file_ = const_cast< ::std::string*>(&_default_machine_key_file_);
  machine_key_encryption_ = NULL;
  local_principles_file_ = const_cast< ::std::string*>(&_default_local_principles_file_);
  bind_ip_ = const_cast< ::std::string*>(&_default_bind_ip_);
  bind_port_ = 0;
  trust_certificate_issuer_cn_ = const_cast< ::std::string*>(&_default_trust_certificate_issuer_cn_);
  trust_certificate_expiration_time_days_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Config::~Config() {
  SharedDtor();
}

void Config::SharedDtor() {
  if (machine_key_file_ != &_default_machine_key_file_) {
    delete machine_key_file_;
  }
  if (local_principles_file_ != &_default_local_principles_file_) {
    delete local_principles_file_;
  }
  if (bind_ip_ != &_default_bind_ip_) {
    delete bind_ip_;
  }
  if (trust_certificate_issuer_cn_ != &_default_trust_certificate_issuer_cn_) {
    delete trust_certificate_issuer_cn_;
  }
  if (this != default_instance_) {
    delete machine_key_encryption_;
  }
}

const ::google::protobuf::Descriptor* Config::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Config_descriptor_;
}

const Config& Config::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

Config* Config::default_instance_ = NULL;

Config* Config::New() const {
  return new Config;
}

void Config::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (machine_key_file_ != &_default_machine_key_file_) {
        machine_key_file_->clear();
      }
    }
    if (_has_bit(1)) {
      if (machine_key_encryption_ != NULL) machine_key_encryption_->::larpc::EncryptionDescriptor::Clear();
    }
    if (_has_bit(2)) {
      if (local_principles_file_ != &_default_local_principles_file_) {
        local_principles_file_->clear();
      }
    }
    if (_has_bit(3)) {
      if (bind_ip_ != &_default_bind_ip_) {
        bind_ip_->clear();
      }
    }
    bind_port_ = 0;
    if (_has_bit(5)) {
      if (trust_certificate_issuer_cn_ != &_default_trust_certificate_issuer_cn_) {
        trust_certificate_issuer_cn_->clear();
      }
    }
    trust_certificate_expiration_time_days_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Config::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string machine_key_file = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_machine_key_file()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->machine_key_file().data(), this->machine_key_file().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_machine_key_encryption;
        break;
      }
      
      // optional .larpc.EncryptionDescriptor machine_key_encryption = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_machine_key_encryption:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_machine_key_encryption()));
        if (input->ExpectTag(26)) goto parse_local_principles_file;
        break;
      }
      
      // required string local_principles_file = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_local_principles_file:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_local_principles_file()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->local_principles_file().data(), this->local_principles_file().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(34)) goto parse_bind_ip;
        break;
      }
      
      // required string bind_ip = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_bind_ip:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_bind_ip()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->bind_ip().data(), this->bind_ip().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(40)) goto parse_bind_port;
        break;
      }
      
      // required int32 bind_port = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_bind_port:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &bind_port_));
        _set_bit(4);
        if (input->ExpectTag(50)) goto parse_trust_certificate_issuer_cn;
        break;
      }
      
      // required string trust_certificate_issuer_cn = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_trust_certificate_issuer_cn:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_trust_certificate_issuer_cn()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->trust_certificate_issuer_cn().data(), this->trust_certificate_issuer_cn().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(56)) goto parse_trust_certificate_expiration_time_days;
        break;
      }
      
      // required int32 trust_certificate_expiration_time_days = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_trust_certificate_expiration_time_days:
        DO_(::google::protobuf::internal::WireFormatLite::ReadInt32(
              input, &trust_certificate_expiration_time_days_));
        _set_bit(6);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Config::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Config::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string machine_key_file = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->machine_key_file().data(), this->machine_key_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->machine_key_file(), output);
  }
  
  // optional .larpc.EncryptionDescriptor machine_key_encryption = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->machine_key_encryption(), output);
  }
  
  // required string local_principles_file = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->local_principles_file().data(), this->local_principles_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->local_principles_file(), output);
  }
  
  // required string bind_ip = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bind_ip().data(), this->bind_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->bind_ip(), output);
  }
  
  // required int32 bind_port = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->bind_port(), output);
  }
  
  // required string trust_certificate_issuer_cn = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->trust_certificate_issuer_cn().data(), this->trust_certificate_issuer_cn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->trust_certificate_issuer_cn(), output);
  }
  
  // required int32 trust_certificate_expiration_time_days = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->trust_certificate_expiration_time_days(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Config::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string machine_key_file = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->machine_key_file().data(), this->machine_key_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->machine_key_file(), target);
  }
  
  // optional .larpc.EncryptionDescriptor machine_key_encryption = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->machine_key_encryption(), target);
  }
  
  // required string local_principles_file = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->local_principles_file().data(), this->local_principles_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->local_principles_file(), target);
  }
  
  // required string bind_ip = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bind_ip().data(), this->bind_ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->bind_ip(), target);
  }
  
  // required int32 bind_port = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->bind_port(), target);
  }
  
  // required string trust_certificate_issuer_cn = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->trust_certificate_issuer_cn().data(), this->trust_certificate_issuer_cn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->trust_certificate_issuer_cn(), target);
  }
  
  // required int32 trust_certificate_expiration_time_days = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->trust_certificate_expiration_time_days(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Config::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string machine_key_file = 1;
    if (has_machine_key_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->machine_key_file());
    }
    
    // optional .larpc.EncryptionDescriptor machine_key_encryption = 2;
    if (has_machine_key_encryption()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->machine_key_encryption());
    }
    
    // required string local_principles_file = 3;
    if (has_local_principles_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->local_principles_file());
    }
    
    // required string bind_ip = 4;
    if (has_bind_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bind_ip());
    }
    
    // required int32 bind_port = 5;
    if (has_bind_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->bind_port());
    }
    
    // required string trust_certificate_issuer_cn = 6;
    if (has_trust_certificate_issuer_cn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trust_certificate_issuer_cn());
    }
    
    // required int32 trust_certificate_expiration_time_days = 7;
    if (has_trust_certificate_expiration_time_days()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->trust_certificate_expiration_time_days());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Config::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Config* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Config*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Config::MergeFrom(const Config& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_machine_key_file(from.machine_key_file());
    }
    if (from._has_bit(1)) {
      mutable_machine_key_encryption()->::larpc::EncryptionDescriptor::MergeFrom(from.machine_key_encryption());
    }
    if (from._has_bit(2)) {
      set_local_principles_file(from.local_principles_file());
    }
    if (from._has_bit(3)) {
      set_bind_ip(from.bind_ip());
    }
    if (from._has_bit(4)) {
      set_bind_port(from.bind_port());
    }
    if (from._has_bit(5)) {
      set_trust_certificate_issuer_cn(from.trust_certificate_issuer_cn());
    }
    if (from._has_bit(6)) {
      set_trust_certificate_expiration_time_days(from.trust_certificate_expiration_time_days());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Config::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Config::CopyFrom(const Config& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Config::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007d) != 0x0000007d) return false;
  
  return true;
}

void Config::Swap(Config* other) {
  if (other != this) {
    std::swap(machine_key_file_, other->machine_key_file_);
    std::swap(machine_key_encryption_, other->machine_key_encryption_);
    std::swap(local_principles_file_, other->local_principles_file_);
    std::swap(bind_ip_, other->bind_ip_);
    std::swap(bind_port_, other->bind_port_);
    std::swap(trust_certificate_issuer_cn_, other->trust_certificate_issuer_cn_);
    std::swap(trust_certificate_expiration_time_days_, other->trust_certificate_expiration_time_days_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Config::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Config_descriptor_;
  metadata.reflection = Config_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChannelMessage::kRequestsFieldNumber;
const int ChannelMessage::kResponsesFieldNumber;
const int ChannelMessage::kControlFieldNumber;
#endif  // !_MSC_VER

ChannelMessage::ChannelMessage() {
  SharedCtor();
}

void ChannelMessage::InitAsDefaultInstance() {
  control_ = const_cast< ::larpc::ChannelControl*>(&::larpc::ChannelControl::default_instance());
}

ChannelMessage::ChannelMessage(const ChannelMessage& from) {
  SharedCtor();
  MergeFrom(from);
}

void ChannelMessage::SharedCtor() {
  _cached_size_ = 0;
  control_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChannelMessage::~ChannelMessage() {
  SharedDtor();
}

void ChannelMessage::SharedDtor() {
  if (this != default_instance_) {
    delete control_;
  }
}

const ::google::protobuf::Descriptor* ChannelMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChannelMessage_descriptor_;
}

const ChannelMessage& ChannelMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

ChannelMessage* ChannelMessage::default_instance_ = NULL;

ChannelMessage* ChannelMessage::New() const {
  return new ChannelMessage;
}

void ChannelMessage::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (_has_bit(2)) {
      if (control_ != NULL) control_->::larpc::ChannelControl::Clear();
    }
  }
  requests_.Clear();
  responses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChannelMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .larpc.RPCRequest requests = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_requests:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_requests()));
        if (input->ExpectTag(10)) goto parse_requests;
        if (input->ExpectTag(18)) goto parse_responses;
        break;
      }
      
      // repeated .larpc.RPCResponse responses = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_responses:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_responses()));
        if (input->ExpectTag(18)) goto parse_responses;
        if (input->ExpectTag(26)) goto parse_control;
        break;
      }
      
      // optional .larpc.ChannelControl control = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_control:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_control()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChannelMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    ChannelMessage::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // repeated .larpc.RPCRequest requests = 1;
  for (int i = 0; i < this->requests_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->requests(i), output);
  }
  
  // repeated .larpc.RPCResponse responses = 2;
  for (int i = 0; i < this->responses_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->responses(i), output);
  }
  
  // optional .larpc.ChannelControl control = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      3, this->control(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChannelMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .larpc.RPCRequest requests = 1;
  for (int i = 0; i < this->requests_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->requests(i), target);
  }
  
  // repeated .larpc.RPCResponse responses = 2;
  for (int i = 0; i < this->responses_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->responses(i), target);
  }
  
  // optional .larpc.ChannelControl control = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->control(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChannelMessage::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional .larpc.ChannelControl control = 3;
    if (has_control()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->control());
    }
    
  }
  // repeated .larpc.RPCRequest requests = 1;
  total_size += 1 * this->requests_size();
  for (int i = 0; i < this->requests_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->requests(i));
  }
  
  // repeated .larpc.RPCResponse responses = 2;
  total_size += 1 * this->responses_size();
  for (int i = 0; i < this->responses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->responses(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void ChannelMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChannelMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChannelMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChannelMessage::MergeFrom(const ChannelMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  requests_.MergeFrom(from.requests_);
  responses_.MergeFrom(from.responses_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from._has_bit(2)) {
      mutable_control()->::larpc::ChannelControl::MergeFrom(from.control());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChannelMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChannelMessage::CopyFrom(const ChannelMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChannelMessage::IsInitialized() const {
  
  if (has_control()) {
    if (!this->control().IsInitialized()) return false;
  }
  return true;
}

void ChannelMessage::Swap(ChannelMessage* other) {
  if (other != this) {
    requests_.Swap(&other->requests_);
    responses_.Swap(&other->responses_);
    std::swap(control_, other->control_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChannelMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChannelMessage_descriptor_;
  metadata.reflection = ChannelMessage_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string ChannelSetup::_default_machine_id_;
#ifndef _MSC_VER
const int ChannelSetup::kMachineIdFieldNumber;
const int ChannelSetup::kPrinciplesFieldNumber;
#endif  // !_MSC_VER

ChannelSetup::ChannelSetup() {
  SharedCtor();
}

void ChannelSetup::InitAsDefaultInstance() {
}

ChannelSetup::ChannelSetup(const ChannelSetup& from) {
  SharedCtor();
  MergeFrom(from);
}

void ChannelSetup::SharedCtor() {
  _cached_size_ = 0;
  machine_id_ = const_cast< ::std::string*>(&_default_machine_id_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChannelSetup::~ChannelSetup() {
  SharedDtor();
}

void ChannelSetup::SharedDtor() {
  if (machine_id_ != &_default_machine_id_) {
    delete machine_id_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* ChannelSetup::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChannelSetup_descriptor_;
}

const ChannelSetup& ChannelSetup::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

ChannelSetup* ChannelSetup::default_instance_ = NULL;

ChannelSetup* ChannelSetup::New() const {
  return new ChannelSetup;
}

void ChannelSetup::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (machine_id_ != &_default_machine_id_) {
        machine_id_->clear();
      }
    }
  }
  principles_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChannelSetup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string machine_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_machine_id()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->machine_id().data(), this->machine_id().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_principles;
        break;
      }
      
      // repeated .larpc.PrincipleDescriptor principles = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_principles:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_principles()));
        if (input->ExpectTag(18)) goto parse_principles;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChannelSetup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    ChannelSetup::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string machine_id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->machine_id().data(), this->machine_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->machine_id(), output);
  }
  
  // repeated .larpc.PrincipleDescriptor principles = 2;
  for (int i = 0; i < this->principles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->principles(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChannelSetup::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string machine_id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->machine_id().data(), this->machine_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->machine_id(), target);
  }
  
  // repeated .larpc.PrincipleDescriptor principles = 2;
  for (int i = 0; i < this->principles_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->principles(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChannelSetup::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string machine_id = 1;
    if (has_machine_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->machine_id());
    }
    
  }
  // repeated .larpc.PrincipleDescriptor principles = 2;
  total_size += 1 * this->principles_size();
  for (int i = 0; i < this->principles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->principles(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void ChannelSetup::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChannelSetup* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChannelSetup*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChannelSetup::MergeFrom(const ChannelSetup& from) {
  GOOGLE_CHECK_NE(&from, this);
  principles_.MergeFrom(from.principles_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_machine_id(from.machine_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChannelSetup::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChannelSetup::CopyFrom(const ChannelSetup& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChannelSetup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  for (int i = 0; i < principles_size(); i++) {
    if (!this->principles(i).IsInitialized()) return false;
  }
  return true;
}

void ChannelSetup::Swap(ChannelSetup* other) {
  if (other != this) {
    std::swap(machine_id_, other->machine_id_);
    principles_.Swap(&other->principles_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChannelSetup::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChannelSetup_descriptor_;
  metadata.reflection = ChannelSetup_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string PrincipleVersionRecord::_default_hash_;
#ifndef _MSC_VER
const int PrincipleVersionRecord::kVersionFieldNumber;
const int PrincipleVersionRecord::kHashFieldNumber;
#endif  // !_MSC_VER

PrincipleVersionRecord::PrincipleVersionRecord() {
  SharedCtor();
}

void PrincipleVersionRecord::InitAsDefaultInstance() {
}

PrincipleVersionRecord::PrincipleVersionRecord(const PrincipleVersionRecord& from) {
  SharedCtor();
  MergeFrom(from);
}

void PrincipleVersionRecord::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  hash_ = const_cast< ::std::string*>(&_default_hash_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PrincipleVersionRecord::~PrincipleVersionRecord() {
  SharedDtor();
}

void PrincipleVersionRecord::SharedDtor() {
  if (hash_ != &_default_hash_) {
    delete hash_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* PrincipleVersionRecord::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PrincipleVersionRecord_descriptor_;
}

const PrincipleVersionRecord& PrincipleVersionRecord::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

PrincipleVersionRecord* PrincipleVersionRecord::default_instance_ = NULL;

PrincipleVersionRecord* PrincipleVersionRecord::New() const {
  return new PrincipleVersionRecord;
}

void PrincipleVersionRecord::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    if (_has_bit(1)) {
      if (hash_ != &_default_hash_) {
        hash_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PrincipleVersionRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &version_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_hash;
        break;
      }
      
      // required string hash = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_hash:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_hash()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->hash().data(), this->hash().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PrincipleVersionRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    PrincipleVersionRecord::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required uint32 version = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }
  
  // required string hash = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hash().data(), this->hash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->hash(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PrincipleVersionRecord::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 version = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }
  
  // required string hash = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->hash().data(), this->hash().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->hash(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PrincipleVersionRecord::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // required string hash = 2;
    if (has_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hash());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void PrincipleVersionRecord::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PrincipleVersionRecord* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PrincipleVersionRecord*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PrincipleVersionRecord::MergeFrom(const PrincipleVersionRecord& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_version(from.version());
    }
    if (from._has_bit(1)) {
      set_hash(from.hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PrincipleVersionRecord::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PrincipleVersionRecord::CopyFrom(const PrincipleVersionRecord& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrincipleVersionRecord::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  
  return true;
}

void PrincipleVersionRecord::Swap(PrincipleVersionRecord* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(hash_, other->hash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PrincipleVersionRecord::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PrincipleVersionRecord_descriptor_;
  metadata.reflection = PrincipleVersionRecord_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string PrincipleDescriptor::_default_display_name_;
const ::std::string PrincipleDescriptor::_default_public_key_;
const ::std::string PrincipleDescriptor::_default_encrypted_private_key_;
#ifndef _MSC_VER
const int PrincipleDescriptor::kDisplayNameFieldNumber;
const int PrincipleDescriptor::kPublicKeyFieldNumber;
const int PrincipleDescriptor::kVersionFieldNumber;
const int PrincipleDescriptor::kTrustingX509CertificateFieldNumber;
const int PrincipleDescriptor::kEncryptedPrivateKeyFieldNumber;
const int PrincipleDescriptor::kPrivateKeyEncryptionDescriptorFieldNumber;
const int PrincipleDescriptor::kPastVersionsFieldNumber;
#endif  // !_MSC_VER

PrincipleDescriptor::PrincipleDescriptor() {
  SharedCtor();
}

void PrincipleDescriptor::InitAsDefaultInstance() {
  private_key_encryption_descriptor_ = const_cast< ::larpc::EncryptionDescriptor*>(&::larpc::EncryptionDescriptor::default_instance());
}

PrincipleDescriptor::PrincipleDescriptor(const PrincipleDescriptor& from) {
  SharedCtor();
  MergeFrom(from);
}

void PrincipleDescriptor::SharedCtor() {
  _cached_size_ = 0;
  display_name_ = const_cast< ::std::string*>(&_default_display_name_);
  public_key_ = const_cast< ::std::string*>(&_default_public_key_);
  version_ = 0u;
  encrypted_private_key_ = const_cast< ::std::string*>(&_default_encrypted_private_key_);
  private_key_encryption_descriptor_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PrincipleDescriptor::~PrincipleDescriptor() {
  SharedDtor();
}

void PrincipleDescriptor::SharedDtor() {
  if (display_name_ != &_default_display_name_) {
    delete display_name_;
  }
  if (public_key_ != &_default_public_key_) {
    delete public_key_;
  }
  if (encrypted_private_key_ != &_default_encrypted_private_key_) {
    delete encrypted_private_key_;
  }
  if (this != default_instance_) {
    delete private_key_encryption_descriptor_;
  }
}

const ::google::protobuf::Descriptor* PrincipleDescriptor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PrincipleDescriptor_descriptor_;
}

const PrincipleDescriptor& PrincipleDescriptor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

PrincipleDescriptor* PrincipleDescriptor::default_instance_ = NULL;

PrincipleDescriptor* PrincipleDescriptor::New() const {
  return new PrincipleDescriptor;
}

void PrincipleDescriptor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (display_name_ != &_default_display_name_) {
        display_name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (public_key_ != &_default_public_key_) {
        public_key_->clear();
      }
    }
    version_ = 0u;
    if (_has_bit(4)) {
      if (encrypted_private_key_ != &_default_encrypted_private_key_) {
        encrypted_private_key_->clear();
      }
    }
    if (_has_bit(5)) {
      if (private_key_encryption_descriptor_ != NULL) private_key_encryption_descriptor_->::larpc::EncryptionDescriptor::Clear();
    }
  }
  trusting_x509_certificate_.Clear();
  past_versions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PrincipleDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string display_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_display_name()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->display_name().data(), this->display_name().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_public_key;
        break;
      }
      
      // required string public_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_public_key:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_public_key()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->public_key().data(), this->public_key().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(24)) goto parse_version;
        break;
      }
      
      // required uint32 version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_version:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &version_));
        _set_bit(2);
        if (input->ExpectTag(34)) goto parse_trusting_x509_certificate;
        break;
      }
      
      // repeated string trusting_x509_certificate = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_trusting_x509_certificate:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->add_trusting_x509_certificate()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->trusting_x509_certificate(0).data(), this->trusting_x509_certificate(0).length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(34)) goto parse_trusting_x509_certificate;
        if (input->ExpectTag(50)) goto parse_encrypted_private_key;
        break;
      }
      
      // optional string encrypted_private_key = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_encrypted_private_key:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_encrypted_private_key()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->encrypted_private_key().data(), this->encrypted_private_key().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(58)) goto parse_private_key_encryption_descriptor;
        break;
      }
      
      // optional .larpc.EncryptionDescriptor private_key_encryption_descriptor = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_private_key_encryption_descriptor:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_private_key_encryption_descriptor()));
        if (input->ExpectTag(66)) goto parse_past_versions;
        break;
      }
      
      // repeated .larpc.PrincipleVersionRecord past_versions = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_past_versions:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_past_versions()));
        if (input->ExpectTag(66)) goto parse_past_versions;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PrincipleDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    PrincipleDescriptor::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required string display_name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->display_name().data(), this->display_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->display_name(), output);
  }
  
  // required string public_key = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_key().data(), this->public_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->public_key(), output);
  }
  
  // required uint32 version = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->version(), output);
  }
  
  // repeated string trusting_x509_certificate = 4;
  for (int i = 0; i < this->trusting_x509_certificate_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->trusting_x509_certificate(i).data(), this->trusting_x509_certificate(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->trusting_x509_certificate(i), output);
  }
  
  // optional string encrypted_private_key = 6;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->encrypted_private_key().data(), this->encrypted_private_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->encrypted_private_key(), output);
  }
  
  // optional .larpc.EncryptionDescriptor private_key_encryption_descriptor = 7;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      7, this->private_key_encryption_descriptor(), output);
  }
  
  // repeated .larpc.PrincipleVersionRecord past_versions = 8;
  for (int i = 0; i < this->past_versions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      8, this->past_versions(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PrincipleDescriptor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string display_name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->display_name().data(), this->display_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->display_name(), target);
  }
  
  // required string public_key = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->public_key().data(), this->public_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->public_key(), target);
  }
  
  // required uint32 version = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->version(), target);
  }
  
  // repeated string trusting_x509_certificate = 4;
  for (int i = 0; i < this->trusting_x509_certificate_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->trusting_x509_certificate(i).data(), this->trusting_x509_certificate(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(4, this->trusting_x509_certificate(i), target);
  }
  
  // optional string encrypted_private_key = 6;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->encrypted_private_key().data(), this->encrypted_private_key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->encrypted_private_key(), target);
  }
  
  // optional .larpc.EncryptionDescriptor private_key_encryption_descriptor = 7;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->private_key_encryption_descriptor(), target);
  }
  
  // repeated .larpc.PrincipleVersionRecord past_versions = 8;
  for (int i = 0; i < this->past_versions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->past_versions(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PrincipleDescriptor::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string display_name = 1;
    if (has_display_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->display_name());
    }
    
    // required string public_key = 2;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->public_key());
    }
    
    // required uint32 version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }
    
    // optional string encrypted_private_key = 6;
    if (has_encrypted_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->encrypted_private_key());
    }
    
    // optional .larpc.EncryptionDescriptor private_key_encryption_descriptor = 7;
    if (has_private_key_encryption_descriptor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->private_key_encryption_descriptor());
    }
    
  }
  // repeated string trusting_x509_certificate = 4;
  total_size += 1 * this->trusting_x509_certificate_size();
  for (int i = 0; i < this->trusting_x509_certificate_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->trusting_x509_certificate(i));
  }
  
  // repeated .larpc.PrincipleVersionRecord past_versions = 8;
  total_size += 1 * this->past_versions_size();
  for (int i = 0; i < this->past_versions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->past_versions(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void PrincipleDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PrincipleDescriptor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PrincipleDescriptor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PrincipleDescriptor::MergeFrom(const PrincipleDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  trusting_x509_certificate_.MergeFrom(from.trusting_x509_certificate_);
  past_versions_.MergeFrom(from.past_versions_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_display_name(from.display_name());
    }
    if (from._has_bit(1)) {
      set_public_key(from.public_key());
    }
    if (from._has_bit(2)) {
      set_version(from.version());
    }
    if (from._has_bit(4)) {
      set_encrypted_private_key(from.encrypted_private_key());
    }
    if (from._has_bit(5)) {
      mutable_private_key_encryption_descriptor()->::larpc::EncryptionDescriptor::MergeFrom(from.private_key_encryption_descriptor());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PrincipleDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PrincipleDescriptor::CopyFrom(const PrincipleDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrincipleDescriptor::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < past_versions_size(); i++) {
    if (!this->past_versions(i).IsInitialized()) return false;
  }
  return true;
}

void PrincipleDescriptor::Swap(PrincipleDescriptor* other) {
  if (other != this) {
    std::swap(display_name_, other->display_name_);
    std::swap(public_key_, other->public_key_);
    std::swap(version_, other->version_);
    trusting_x509_certificate_.Swap(&other->trusting_x509_certificate_);
    std::swap(encrypted_private_key_, other->encrypted_private_key_);
    std::swap(private_key_encryption_descriptor_, other->private_key_encryption_descriptor_);
    past_versions_.Swap(&other->past_versions_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PrincipleDescriptor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PrincipleDescriptor_descriptor_;
  metadata.reflection = PrincipleDescriptor_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string MethodDescriptor::_default_method_name_;
#ifndef _MSC_VER
const int MethodDescriptor::kMethodNameFieldNumber;
#endif  // !_MSC_VER

MethodDescriptor::MethodDescriptor() {
  SharedCtor();
}

void MethodDescriptor::InitAsDefaultInstance() {
}

MethodDescriptor::MethodDescriptor(const MethodDescriptor& from) {
  SharedCtor();
  MergeFrom(from);
}

void MethodDescriptor::SharedCtor() {
  _cached_size_ = 0;
  method_name_ = const_cast< ::std::string*>(&_default_method_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MethodDescriptor::~MethodDescriptor() {
  SharedDtor();
}

void MethodDescriptor::SharedDtor() {
  if (method_name_ != &_default_method_name_) {
    delete method_name_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* MethodDescriptor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MethodDescriptor_descriptor_;
}

const MethodDescriptor& MethodDescriptor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

MethodDescriptor* MethodDescriptor::default_instance_ = NULL;

MethodDescriptor* MethodDescriptor::New() const {
  return new MethodDescriptor;
}

void MethodDescriptor::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (method_name_ != &_default_method_name_) {
        method_name_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MethodDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string method_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_method_name()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->method_name().data(), this->method_name().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MethodDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    MethodDescriptor::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional string method_name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->method_name().data(), this->method_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->method_name(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MethodDescriptor::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string method_name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->method_name().data(), this->method_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->method_name(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MethodDescriptor::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string method_name = 1;
    if (has_method_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->method_name());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void MethodDescriptor::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MethodDescriptor* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MethodDescriptor*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MethodDescriptor::MergeFrom(const MethodDescriptor& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_method_name(from.method_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MethodDescriptor::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MethodDescriptor::CopyFrom(const MethodDescriptor& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MethodDescriptor::IsInitialized() const {
  
  return true;
}

void MethodDescriptor::Swap(MethodDescriptor* other) {
  if (other != this) {
    std::swap(method_name_, other->method_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MethodDescriptor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MethodDescriptor_descriptor_;
  metadata.reflection = MethodDescriptor_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string RPCRequest::_default_channel_id_;
const ::std::string RPCRequest::_default_method_parameters_;
#ifndef _MSC_VER
const int RPCRequest::kChannelIdFieldNumber;
const int RPCRequest::kRequestIdFieldNumber;
const int RPCRequest::kMethodIdFieldNumber;
const int RPCRequest::kMethodParametersFieldNumber;
#endif  // !_MSC_VER

RPCRequest::RPCRequest() {
  SharedCtor();
}

void RPCRequest::InitAsDefaultInstance() {
  method_id_ = const_cast< ::larpc::MethodDescriptor*>(&::larpc::MethodDescriptor::default_instance());
}

RPCRequest::RPCRequest(const RPCRequest& from) {
  SharedCtor();
  MergeFrom(from);
}

void RPCRequest::SharedCtor() {
  _cached_size_ = 0;
  channel_id_ = const_cast< ::std::string*>(&_default_channel_id_);
  request_id_ = 0u;
  method_id_ = NULL;
  method_parameters_ = const_cast< ::std::string*>(&_default_method_parameters_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RPCRequest::~RPCRequest() {
  SharedDtor();
}

void RPCRequest::SharedDtor() {
  if (channel_id_ != &_default_channel_id_) {
    delete channel_id_;
  }
  if (method_parameters_ != &_default_method_parameters_) {
    delete method_parameters_;
  }
  if (this != default_instance_) {
    delete method_id_;
  }
}

const ::google::protobuf::Descriptor* RPCRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RPCRequest_descriptor_;
}

const RPCRequest& RPCRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

RPCRequest* RPCRequest::default_instance_ = NULL;

RPCRequest* RPCRequest::New() const {
  return new RPCRequest;
}

void RPCRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (channel_id_ != &_default_channel_id_) {
        channel_id_->clear();
      }
    }
    request_id_ = 0u;
    if (_has_bit(2)) {
      if (method_id_ != NULL) method_id_->::larpc::MethodDescriptor::Clear();
    }
    if (_has_bit(3)) {
      if (method_parameters_ != &_default_method_parameters_) {
        method_parameters_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RPCRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string channel_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_channel_id()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->channel_id().data(), this->channel_id().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(16)) goto parse_request_id;
        break;
      }
      
      // optional uint32 request_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_request_id:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &request_id_));
        _set_bit(1);
        if (input->ExpectTag(26)) goto parse_method_id;
        break;
      }
      
      // optional .larpc.MethodDescriptor method_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_method_id:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_method_id()));
        if (input->ExpectTag(34)) goto parse_method_parameters;
        break;
      }
      
      // optional bytes method_parameters = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_method_parameters:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
              input, this->mutable_method_parameters()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RPCRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    RPCRequest::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional string channel_id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->channel_id().data(), this->channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->channel_id(), output);
  }
  
  // optional uint32 request_id = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->request_id(), output);
  }
  
  // optional .larpc.MethodDescriptor method_id = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      3, this->method_id(), output);
  }
  
  // optional bytes method_parameters = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->method_parameters(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RPCRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string channel_id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->channel_id().data(), this->channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->channel_id(), target);
  }
  
  // optional uint32 request_id = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->request_id(), target);
  }
  
  // optional .larpc.MethodDescriptor method_id = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->method_id(), target);
  }
  
  // optional bytes method_parameters = 4;
  if (_has_bit(3)) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->method_parameters(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RPCRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string channel_id = 1;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->channel_id());
    }
    
    // optional uint32 request_id = 2;
    if (has_request_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->request_id());
    }
    
    // optional .larpc.MethodDescriptor method_id = 3;
    if (has_method_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->method_id());
    }
    
    // optional bytes method_parameters = 4;
    if (has_method_parameters()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->method_parameters());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void RPCRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RPCRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RPCRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RPCRequest::MergeFrom(const RPCRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_channel_id(from.channel_id());
    }
    if (from._has_bit(1)) {
      set_request_id(from.request_id());
    }
    if (from._has_bit(2)) {
      mutable_method_id()->::larpc::MethodDescriptor::MergeFrom(from.method_id());
    }
    if (from._has_bit(3)) {
      set_method_parameters(from.method_parameters());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RPCRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RPCRequest::CopyFrom(const RPCRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RPCRequest::IsInitialized() const {
  
  return true;
}

void RPCRequest::Swap(RPCRequest* other) {
  if (other != this) {
    std::swap(channel_id_, other->channel_id_);
    std::swap(request_id_, other->request_id_);
    std::swap(method_id_, other->method_id_);
    std::swap(method_parameters_, other->method_parameters_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RPCRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RPCRequest_descriptor_;
  metadata.reflection = RPCRequest_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string RPCResponse::_default_channel_id_;
const ::std::string RPCResponse::_default_response_;
#ifndef _MSC_VER
const int RPCResponse::kChannelIdFieldNumber;
const int RPCResponse::kRequestIdFieldNumber;
const int RPCResponse::kResponseFieldNumber;
#endif  // !_MSC_VER

RPCResponse::RPCResponse() {
  SharedCtor();
}

void RPCResponse::InitAsDefaultInstance() {
}

RPCResponse::RPCResponse(const RPCResponse& from) {
  SharedCtor();
  MergeFrom(from);
}

void RPCResponse::SharedCtor() {
  _cached_size_ = 0;
  channel_id_ = const_cast< ::std::string*>(&_default_channel_id_);
  request_id_ = 0u;
  response_ = const_cast< ::std::string*>(&_default_response_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RPCResponse::~RPCResponse() {
  SharedDtor();
}

void RPCResponse::SharedDtor() {
  if (channel_id_ != &_default_channel_id_) {
    delete channel_id_;
  }
  if (response_ != &_default_response_) {
    delete response_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* RPCResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RPCResponse_descriptor_;
}

const RPCResponse& RPCResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

RPCResponse* RPCResponse::default_instance_ = NULL;

RPCResponse* RPCResponse::New() const {
  return new RPCResponse;
}

void RPCResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (channel_id_ != &_default_channel_id_) {
        channel_id_->clear();
      }
    }
    request_id_ = 0u;
    if (_has_bit(2)) {
      if (response_ != &_default_response_) {
        response_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RPCResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string channel_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_channel_id()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->channel_id().data(), this->channel_id().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(16)) goto parse_request_id;
        break;
      }
      
      // optional uint32 request_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_request_id:
        DO_(::google::protobuf::internal::WireFormatLite::ReadUInt32(
              input, &request_id_));
        _set_bit(1);
        if (input->ExpectTag(26)) goto parse_response;
        break;
      }
      
      // optional bytes response = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_response:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
              input, this->mutable_response()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RPCResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    RPCResponse::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional string channel_id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->channel_id().data(), this->channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->channel_id(), output);
  }
  
  // optional uint32 request_id = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->request_id(), output);
  }
  
  // optional bytes response = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->response(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RPCResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string channel_id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->channel_id().data(), this->channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->channel_id(), target);
  }
  
  // optional uint32 request_id = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->request_id(), target);
  }
  
  // optional bytes response = 3;
  if (_has_bit(2)) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->response(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RPCResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string channel_id = 1;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->channel_id());
    }
    
    // optional uint32 request_id = 2;
    if (has_request_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->request_id());
    }
    
    // optional bytes response = 3;
    if (has_response()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->response());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void RPCResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RPCResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RPCResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RPCResponse::MergeFrom(const RPCResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_channel_id(from.channel_id());
    }
    if (from._has_bit(1)) {
      set_request_id(from.request_id());
    }
    if (from._has_bit(2)) {
      set_response(from.response());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RPCResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RPCResponse::CopyFrom(const RPCResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RPCResponse::IsInitialized() const {
  
  return true;
}

void RPCResponse::Swap(RPCResponse* other) {
  if (other != this) {
    std::swap(channel_id_, other->channel_id_);
    std::swap(request_id_, other->request_id_);
    std::swap(response_, other->response_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RPCResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RPCResponse_descriptor_;
  metadata.reflection = RPCResponse_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string OpenChannelRequest::_default_initiator_public_key_;
const ::std::string OpenChannelRequest::_default_initiator_certificate_;
const ::std::string OpenChannelRequest::_default_channel_id_;
#ifndef _MSC_VER
const int OpenChannelRequest::kInitiatorPublicKeyFieldNumber;
const int OpenChannelRequest::kInitiatorCertificateFieldNumber;
const int OpenChannelRequest::kDesiredPrincipleFieldNumber;
const int OpenChannelRequest::kChannelIdFieldNumber;
#endif  // !_MSC_VER

OpenChannelRequest::OpenChannelRequest() {
  SharedCtor();
}

void OpenChannelRequest::InitAsDefaultInstance() {
  desired_principle_ = const_cast< ::larpc::PrincipleDescriptor*>(&::larpc::PrincipleDescriptor::default_instance());
}

OpenChannelRequest::OpenChannelRequest(const OpenChannelRequest& from) {
  SharedCtor();
  MergeFrom(from);
}

void OpenChannelRequest::SharedCtor() {
  _cached_size_ = 0;
  initiator_public_key_ = const_cast< ::std::string*>(&_default_initiator_public_key_);
  initiator_certificate_ = const_cast< ::std::string*>(&_default_initiator_certificate_);
  desired_principle_ = NULL;
  channel_id_ = const_cast< ::std::string*>(&_default_channel_id_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenChannelRequest::~OpenChannelRequest() {
  SharedDtor();
}

void OpenChannelRequest::SharedDtor() {
  if (initiator_public_key_ != &_default_initiator_public_key_) {
    delete initiator_public_key_;
  }
  if (initiator_certificate_ != &_default_initiator_certificate_) {
    delete initiator_certificate_;
  }
  if (channel_id_ != &_default_channel_id_) {
    delete channel_id_;
  }
  if (this != default_instance_) {
    delete desired_principle_;
  }
}

const ::google::protobuf::Descriptor* OpenChannelRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OpenChannelRequest_descriptor_;
}

const OpenChannelRequest& OpenChannelRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

OpenChannelRequest* OpenChannelRequest::default_instance_ = NULL;

OpenChannelRequest* OpenChannelRequest::New() const {
  return new OpenChannelRequest;
}

void OpenChannelRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (initiator_public_key_ != &_default_initiator_public_key_) {
        initiator_public_key_->clear();
      }
    }
    if (_has_bit(1)) {
      if (initiator_certificate_ != &_default_initiator_certificate_) {
        initiator_certificate_->clear();
      }
    }
    if (_has_bit(2)) {
      if (desired_principle_ != NULL) desired_principle_->::larpc::PrincipleDescriptor::Clear();
    }
    if (_has_bit(3)) {
      if (channel_id_ != &_default_channel_id_) {
        channel_id_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OpenChannelRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes initiator_public_key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
              input, this->mutable_initiator_public_key()));
        if (input->ExpectTag(18)) goto parse_initiator_certificate;
        break;
      }
      
      // optional bytes initiator_certificate = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_initiator_certificate:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
              input, this->mutable_initiator_certificate()));
        if (input->ExpectTag(26)) goto parse_desired_principle;
        break;
      }
      
      // optional .larpc.PrincipleDescriptor desired_principle = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_desired_principle:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
             input, mutable_desired_principle()));
        if (input->ExpectTag(34)) goto parse_channel_id;
        break;
      }
      
      // optional string channel_id = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_channel_id:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_channel_id()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->channel_id().data(), this->channel_id().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OpenChannelRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    OpenChannelRequest::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional bytes initiator_public_key = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->initiator_public_key(), output);
  }
  
  // optional bytes initiator_certificate = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->initiator_certificate(), output);
  }
  
  // optional .larpc.PrincipleDescriptor desired_principle = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      3, this->desired_principle(), output);
  }
  
  // optional string channel_id = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->channel_id().data(), this->channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->channel_id(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OpenChannelRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes initiator_public_key = 1;
  if (_has_bit(0)) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->initiator_public_key(), target);
  }
  
  // optional bytes initiator_certificate = 2;
  if (_has_bit(1)) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->initiator_certificate(), target);
  }
  
  // optional .larpc.PrincipleDescriptor desired_principle = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->desired_principle(), target);
  }
  
  // optional string channel_id = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->channel_id().data(), this->channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->channel_id(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OpenChannelRequest::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes initiator_public_key = 1;
    if (has_initiator_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->initiator_public_key());
    }
    
    // optional bytes initiator_certificate = 2;
    if (has_initiator_certificate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->initiator_certificate());
    }
    
    // optional .larpc.PrincipleDescriptor desired_principle = 3;
    if (has_desired_principle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->desired_principle());
    }
    
    // optional string channel_id = 4;
    if (has_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->channel_id());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void OpenChannelRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OpenChannelRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OpenChannelRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OpenChannelRequest::MergeFrom(const OpenChannelRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_initiator_public_key(from.initiator_public_key());
    }
    if (from._has_bit(1)) {
      set_initiator_certificate(from.initiator_certificate());
    }
    if (from._has_bit(2)) {
      mutable_desired_principle()->::larpc::PrincipleDescriptor::MergeFrom(from.desired_principle());
    }
    if (from._has_bit(3)) {
      set_channel_id(from.channel_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OpenChannelRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpenChannelRequest::CopyFrom(const OpenChannelRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenChannelRequest::IsInitialized() const {
  
  if (has_desired_principle()) {
    if (!this->desired_principle().IsInitialized()) return false;
  }
  return true;
}

void OpenChannelRequest::Swap(OpenChannelRequest* other) {
  if (other != this) {
    std::swap(initiator_public_key_, other->initiator_public_key_);
    std::swap(initiator_certificate_, other->initiator_certificate_);
    std::swap(desired_principle_, other->desired_principle_);
    std::swap(channel_id_, other->channel_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OpenChannelRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OpenChannelRequest_descriptor_;
  metadata.reflection = OpenChannelRequest_reflection_;
  return metadata;
}


// ===================================================================

const ::std::string OpenChannelResponse::_default_initiator_channel_id_;
const ::std::string OpenChannelResponse::_default_responding_channel_id_;
const ::std::string OpenChannelResponse::_default_responding_certificate_;
#ifndef _MSC_VER
const int OpenChannelResponse::kInitiatorChannelIdFieldNumber;
const int OpenChannelResponse::kRespondingChannelIdFieldNumber;
const int OpenChannelResponse::kRespondingCertificateFieldNumber;
#endif  // !_MSC_VER

OpenChannelResponse::OpenChannelResponse() {
  SharedCtor();
}

void OpenChannelResponse::InitAsDefaultInstance() {
}

OpenChannelResponse::OpenChannelResponse(const OpenChannelResponse& from) {
  SharedCtor();
  MergeFrom(from);
}

void OpenChannelResponse::SharedCtor() {
  _cached_size_ = 0;
  initiator_channel_id_ = const_cast< ::std::string*>(&_default_initiator_channel_id_);
  responding_channel_id_ = const_cast< ::std::string*>(&_default_responding_channel_id_);
  responding_certificate_ = const_cast< ::std::string*>(&_default_responding_certificate_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenChannelResponse::~OpenChannelResponse() {
  SharedDtor();
}

void OpenChannelResponse::SharedDtor() {
  if (initiator_channel_id_ != &_default_initiator_channel_id_) {
    delete initiator_channel_id_;
  }
  if (responding_channel_id_ != &_default_responding_channel_id_) {
    delete responding_channel_id_;
  }
  if (responding_certificate_ != &_default_responding_certificate_) {
    delete responding_certificate_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* OpenChannelResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OpenChannelResponse_descriptor_;
}

const OpenChannelResponse& OpenChannelResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

OpenChannelResponse* OpenChannelResponse::default_instance_ = NULL;

OpenChannelResponse* OpenChannelResponse::New() const {
  return new OpenChannelResponse;
}

void OpenChannelResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (initiator_channel_id_ != &_default_initiator_channel_id_) {
        initiator_channel_id_->clear();
      }
    }
    if (_has_bit(1)) {
      if (responding_channel_id_ != &_default_responding_channel_id_) {
        responding_channel_id_->clear();
      }
    }
    if (_has_bit(2)) {
      if (responding_certificate_ != &_default_responding_certificate_) {
        responding_certificate_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OpenChannelResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string initiator_channel_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_initiator_channel_id()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->initiator_channel_id().data(), this->initiator_channel_id().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(18)) goto parse_responding_channel_id;
        break;
      }
      
      // optional string responding_channel_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_responding_channel_id:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->mutable_responding_channel_id()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->responding_channel_id().data(), this->responding_channel_id().length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(26)) goto parse_responding_certificate;
        break;
      }
      
      // optional bytes responding_certificate = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_responding_certificate:
        DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
              input, this->mutable_responding_certificate()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OpenChannelResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    OpenChannelResponse::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional string initiator_channel_id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->initiator_channel_id().data(), this->initiator_channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->initiator_channel_id(), output);
  }
  
  // optional string responding_channel_id = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->responding_channel_id().data(), this->responding_channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->responding_channel_id(), output);
  }
  
  // optional bytes responding_certificate = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->responding_certificate(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OpenChannelResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string initiator_channel_id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->initiator_channel_id().data(), this->initiator_channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->initiator_channel_id(), target);
  }
  
  // optional string responding_channel_id = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->responding_channel_id().data(), this->responding_channel_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->responding_channel_id(), target);
  }
  
  // optional bytes responding_certificate = 3;
  if (_has_bit(2)) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->responding_certificate(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OpenChannelResponse::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string initiator_channel_id = 1;
    if (has_initiator_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->initiator_channel_id());
    }
    
    // optional string responding_channel_id = 2;
    if (has_responding_channel_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->responding_channel_id());
    }
    
    // optional bytes responding_certificate = 3;
    if (has_responding_certificate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->responding_certificate());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void OpenChannelResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OpenChannelResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OpenChannelResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OpenChannelResponse::MergeFrom(const OpenChannelResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_initiator_channel_id(from.initiator_channel_id());
    }
    if (from._has_bit(1)) {
      set_responding_channel_id(from.responding_channel_id());
    }
    if (from._has_bit(2)) {
      set_responding_certificate(from.responding_certificate());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OpenChannelResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpenChannelResponse::CopyFrom(const OpenChannelResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenChannelResponse::IsInitialized() const {
  
  return true;
}

void OpenChannelResponse::Swap(OpenChannelResponse* other) {
  if (other != this) {
    std::swap(initiator_channel_id_, other->initiator_channel_id_);
    std::swap(responding_channel_id_, other->responding_channel_id_);
    std::swap(responding_certificate_, other->responding_certificate_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OpenChannelResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OpenChannelResponse_descriptor_;
  metadata.reflection = OpenChannelResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChannelControl::kOpenChannelRequestFieldNumber;
const int ChannelControl::kOpenChannelResponseFieldNumber;
const int ChannelControl::kCloseChannelIdFieldNumber;
#endif  // !_MSC_VER

ChannelControl::ChannelControl() {
  SharedCtor();
}

void ChannelControl::InitAsDefaultInstance() {
}

ChannelControl::ChannelControl(const ChannelControl& from) {
  SharedCtor();
  MergeFrom(from);
}

void ChannelControl::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChannelControl::~ChannelControl() {
  SharedDtor();
}

void ChannelControl::SharedDtor() {
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* ChannelControl::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChannelControl_descriptor_;
}

const ChannelControl& ChannelControl::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_larpc_2eproto();  return *default_instance_;
}

ChannelControl* ChannelControl::default_instance_ = NULL;

ChannelControl* ChannelControl::New() const {
  return new ChannelControl;
}

void ChannelControl::Clear() {
  open_channel_request_.Clear();
  open_channel_response_.Clear();
  close_channel_id_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChannelControl::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .larpc.OpenChannelRequest open_channel_request = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_open_channel_request:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_open_channel_request()));
        if (input->ExpectTag(10)) goto parse_open_channel_request;
        if (input->ExpectTag(18)) goto parse_open_channel_response;
        break;
      }
      
      // repeated .larpc.OpenChannelResponse open_channel_response = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_open_channel_response:
        DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, add_open_channel_response()));
        if (input->ExpectTag(18)) goto parse_open_channel_response;
        if (input->ExpectTag(26)) goto parse_close_channel_id;
        break;
      }
      
      // repeated string close_channel_id = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_close_channel_id:
        DO_(::google::protobuf::internal::WireFormatLite::ReadString(
              input, this->add_close_channel_id()));
        ::google::protobuf::internal::WireFormat::VerifyUTF8String(
          this->close_channel_id(0).data(), this->close_channel_id(0).length(),
          ::google::protobuf::internal::WireFormat::PARSE);
        if (input->ExpectTag(26)) goto parse_close_channel_id;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChannelControl::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    ChannelControl::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // repeated .larpc.OpenChannelRequest open_channel_request = 1;
  for (int i = 0; i < this->open_channel_request_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      1, this->open_channel_request(i), output);
  }
  
  // repeated .larpc.OpenChannelResponse open_channel_response = 2;
  for (int i = 0; i < this->open_channel_response_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageNoVirtual(
      2, this->open_channel_response(i), output);
  }
  
  // repeated string close_channel_id = 3;
  for (int i = 0; i < this->close_channel_id_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->close_channel_id(i).data(), this->close_channel_id(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->close_channel_id(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChannelControl::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .larpc.OpenChannelRequest open_channel_request = 1;
  for (int i = 0; i < this->open_channel_request_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->open_channel_request(i), target);
  }
  
  // repeated .larpc.OpenChannelResponse open_channel_response = 2;
  for (int i = 0; i < this->open_channel_response_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->open_channel_response(i), target);
  }
  
  // repeated string close_channel_id = 3;
  for (int i = 0; i < this->close_channel_id_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->close_channel_id(i).data(), this->close_channel_id(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->close_channel_id(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChannelControl::ByteSize() const {
  int total_size = 0;
  
  // repeated .larpc.OpenChannelRequest open_channel_request = 1;
  total_size += 1 * this->open_channel_request_size();
  for (int i = 0; i < this->open_channel_request_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->open_channel_request(i));
  }
  
  // repeated .larpc.OpenChannelResponse open_channel_response = 2;
  total_size += 1 * this->open_channel_response_size();
  for (int i = 0; i < this->open_channel_response_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->open_channel_response(i));
  }
  
  // repeated string close_channel_id = 3;
  total_size += 1 * this->close_channel_id_size();
  for (int i = 0; i < this->close_channel_id_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->close_channel_id(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void ChannelControl::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChannelControl* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChannelControl*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChannelControl::MergeFrom(const ChannelControl& from) {
  GOOGLE_CHECK_NE(&from, this);
  open_channel_request_.MergeFrom(from.open_channel_request_);
  open_channel_response_.MergeFrom(from.open_channel_response_);
  close_channel_id_.MergeFrom(from.close_channel_id_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChannelControl::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChannelControl::CopyFrom(const ChannelControl& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChannelControl::IsInitialized() const {
  
  for (int i = 0; i < open_channel_request_size(); i++) {
    if (!this->open_channel_request(i).IsInitialized()) return false;
  }
  return true;
}

void ChannelControl::Swap(ChannelControl* other) {
  if (other != this) {
    open_channel_request_.Swap(&other->open_channel_request_);
    open_channel_response_.Swap(&other->open_channel_response_);
    close_channel_id_.Swap(&other->close_channel_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChannelControl::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChannelControl_descriptor_;
  metadata.reflection = ChannelControl_reflection_;
  return metadata;
}


}  // namespace larpc
