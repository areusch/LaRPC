// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_larpc_2eproto__INCLUDED
#define PROTOBUF_larpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>

namespace larpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_larpc_2eproto();
void protobuf_AssignDesc_larpc_2eproto();
void protobuf_ShutdownFile_larpc_2eproto();

class EncryptionDescriptor;
class KeygenParameters;
class MachineKey;
class Config;
class ChannelMessage;
class ChannelSetup;
class PrincipleVersionRecord;
class PrincipleDescriptor;
class MethodDescriptor;
class RPCRequest;
class RPCResponse;
class OpenChannelRequest;
class OpenChannelResponse;
class ChannelControl;

// ===================================================================

class EncryptionDescriptor : public ::google::protobuf::Message {
 public:
  EncryptionDescriptor();
  virtual ~EncryptionDescriptor();
  
  EncryptionDescriptor(const EncryptionDescriptor& from);
  
  inline EncryptionDescriptor& operator=(const EncryptionDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptionDescriptor& default_instance();
  void Swap(EncryptionDescriptor* other);
  
  // implements Message ----------------------------------------------
  
  EncryptionDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncryptionDescriptor& from);
  void MergeFrom(const EncryptionDescriptor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string cipher = 1;
  inline bool has_cipher() const;
  inline void clear_cipher();
  static const int kCipherFieldNumber = 1;
  inline const ::std::string& cipher() const;
  inline void set_cipher(const ::std::string& value);
  inline void set_cipher(const char* value);
  inline void set_cipher(const char* value, size_t size);
  inline ::std::string* mutable_cipher();
  
  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional string iv = 3;
  inline bool has_iv() const;
  inline void clear_iv();
  static const int kIvFieldNumber = 3;
  inline const ::std::string& iv() const;
  inline void set_iv(const ::std::string& value);
  inline void set_iv(const char* value);
  inline void set_iv(const char* value, size_t size);
  inline ::std::string* mutable_iv();
  
  // optional bool is_password_based = 4 [default = false];
  inline bool has_is_password_based() const;
  inline void clear_is_password_based();
  static const int kIsPasswordBasedFieldNumber = 4;
  inline bool is_password_based() const;
  inline void set_is_password_based(bool value);
  
  // optional string password_digest_algorithm = 5;
  inline bool has_password_digest_algorithm() const;
  inline void clear_password_digest_algorithm();
  static const int kPasswordDigestAlgorithmFieldNumber = 5;
  inline const ::std::string& password_digest_algorithm() const;
  inline void set_password_digest_algorithm(const ::std::string& value);
  inline void set_password_digest_algorithm(const char* value);
  inline void set_password_digest_algorithm(const char* value, size_t size);
  inline ::std::string* mutable_password_digest_algorithm();
  
  // optional string key_hash = 6;
  inline bool has_key_hash() const;
  inline void clear_key_hash();
  static const int kKeyHashFieldNumber = 6;
  inline const ::std::string& key_hash() const;
  inline void set_key_hash(const ::std::string& value);
  inline void set_key_hash(const char* value);
  inline void set_key_hash(const char* value, size_t size);
  inline ::std::string* mutable_key_hash();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* cipher_;
  static const ::std::string _default_cipher_;
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* iv_;
  static const ::std::string _default_iv_;
  bool is_password_based_;
  ::std::string* password_digest_algorithm_;
  static const ::std::string _default_password_digest_algorithm_;
  ::std::string* key_hash_;
  static const ::std::string _default_key_hash_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static EncryptionDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class KeygenParameters : public ::google::protobuf::Message {
 public:
  KeygenParameters();
  virtual ~KeygenParameters();
  
  KeygenParameters(const KeygenParameters& from);
  
  inline KeygenParameters& operator=(const KeygenParameters& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeygenParameters& default_instance();
  void Swap(KeygenParameters* other);
  
  // implements Message ----------------------------------------------
  
  KeygenParameters* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeygenParameters& from);
  void MergeFrom(const KeygenParameters& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key_type = 1;
  inline bool has_key_type() const;
  inline void clear_key_type();
  static const int kKeyTypeFieldNumber = 1;
  inline const ::std::string& key_type() const;
  inline void set_key_type(const ::std::string& value);
  inline void set_key_type(const char* value);
  inline void set_key_type(const char* value, size_t size);
  inline ::std::string* mutable_key_type();
  
  // optional uint32 num_bits = 2;
  inline bool has_num_bits() const;
  inline void clear_num_bits();
  static const int kNumBitsFieldNumber = 2;
  inline ::google::protobuf::uint32 num_bits() const;
  inline void set_num_bits(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_type_;
  static const ::std::string _default_key_type_;
  ::google::protobuf::uint32 num_bits_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static KeygenParameters* default_instance_;
};
// -------------------------------------------------------------------

class MachineKey : public ::google::protobuf::Message {
 public:
  MachineKey();
  virtual ~MachineKey();
  
  MachineKey(const MachineKey& from);
  
  inline MachineKey& operator=(const MachineKey& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MachineKey& default_instance();
  void Swap(MachineKey* other);
  
  // implements Message ----------------------------------------------
  
  MachineKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MachineKey& from);
  void MergeFrom(const MachineKey& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string public_key = 1;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required string private_key = 2;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 2;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const char* value, size_t size);
  inline ::std::string* mutable_private_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MachineKey* default_instance_;
};
// -------------------------------------------------------------------

class Config : public ::google::protobuf::Message {
 public:
  Config();
  virtual ~Config();
  
  Config(const Config& from);
  
  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();
  void Swap(Config* other);
  
  // implements Message ----------------------------------------------
  
  Config* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string machine_key_file = 1;
  inline bool has_machine_key_file() const;
  inline void clear_machine_key_file();
  static const int kMachineKeyFileFieldNumber = 1;
  inline const ::std::string& machine_key_file() const;
  inline void set_machine_key_file(const ::std::string& value);
  inline void set_machine_key_file(const char* value);
  inline void set_machine_key_file(const char* value, size_t size);
  inline ::std::string* mutable_machine_key_file();
  
  // optional .larpc.EncryptionDescriptor machine_key_encryption = 2;
  inline bool has_machine_key_encryption() const;
  inline void clear_machine_key_encryption();
  static const int kMachineKeyEncryptionFieldNumber = 2;
  inline const ::larpc::EncryptionDescriptor& machine_key_encryption() const;
  inline ::larpc::EncryptionDescriptor* mutable_machine_key_encryption();
  
  // required string local_principles_file = 3;
  inline bool has_local_principles_file() const;
  inline void clear_local_principles_file();
  static const int kLocalPrinciplesFileFieldNumber = 3;
  inline const ::std::string& local_principles_file() const;
  inline void set_local_principles_file(const ::std::string& value);
  inline void set_local_principles_file(const char* value);
  inline void set_local_principles_file(const char* value, size_t size);
  inline ::std::string* mutable_local_principles_file();
  
  // required string bind_ip = 4;
  inline bool has_bind_ip() const;
  inline void clear_bind_ip();
  static const int kBindIpFieldNumber = 4;
  inline const ::std::string& bind_ip() const;
  inline void set_bind_ip(const ::std::string& value);
  inline void set_bind_ip(const char* value);
  inline void set_bind_ip(const char* value, size_t size);
  inline ::std::string* mutable_bind_ip();
  
  // required int32 bind_port = 5;
  inline bool has_bind_port() const;
  inline void clear_bind_port();
  static const int kBindPortFieldNumber = 5;
  inline ::google::protobuf::int32 bind_port() const;
  inline void set_bind_port(::google::protobuf::int32 value);
  
  // required string trust_certificate_issuer_cn = 6;
  inline bool has_trust_certificate_issuer_cn() const;
  inline void clear_trust_certificate_issuer_cn();
  static const int kTrustCertificateIssuerCnFieldNumber = 6;
  inline const ::std::string& trust_certificate_issuer_cn() const;
  inline void set_trust_certificate_issuer_cn(const ::std::string& value);
  inline void set_trust_certificate_issuer_cn(const char* value);
  inline void set_trust_certificate_issuer_cn(const char* value, size_t size);
  inline ::std::string* mutable_trust_certificate_issuer_cn();
  
  // required int32 trust_certificate_expiration_time_days = 7;
  inline bool has_trust_certificate_expiration_time_days() const;
  inline void clear_trust_certificate_expiration_time_days();
  static const int kTrustCertificateExpirationTimeDaysFieldNumber = 7;
  inline ::google::protobuf::int32 trust_certificate_expiration_time_days() const;
  inline void set_trust_certificate_expiration_time_days(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* machine_key_file_;
  static const ::std::string _default_machine_key_file_;
  ::larpc::EncryptionDescriptor* machine_key_encryption_;
  ::std::string* local_principles_file_;
  static const ::std::string _default_local_principles_file_;
  ::std::string* bind_ip_;
  static const ::std::string _default_bind_ip_;
  ::google::protobuf::int32 bind_port_;
  ::std::string* trust_certificate_issuer_cn_;
  static const ::std::string _default_trust_certificate_issuer_cn_;
  ::google::protobuf::int32 trust_certificate_expiration_time_days_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Config* default_instance_;
};
// -------------------------------------------------------------------

class ChannelMessage : public ::google::protobuf::Message {
 public:
  ChannelMessage();
  virtual ~ChannelMessage();
  
  ChannelMessage(const ChannelMessage& from);
  
  inline ChannelMessage& operator=(const ChannelMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelMessage& default_instance();
  void Swap(ChannelMessage* other);
  
  // implements Message ----------------------------------------------
  
  ChannelMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChannelMessage& from);
  void MergeFrom(const ChannelMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .larpc.RPCRequest requests = 1;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::larpc::RPCRequest >& requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::larpc::RPCRequest >* mutable_requests();
  inline const ::larpc::RPCRequest& requests(int index) const;
  inline ::larpc::RPCRequest* mutable_requests(int index);
  inline ::larpc::RPCRequest* add_requests();
  
  // repeated .larpc.RPCResponse responses = 2;
  inline int responses_size() const;
  inline void clear_responses();
  static const int kResponsesFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::larpc::RPCResponse >& responses() const;
  inline ::google::protobuf::RepeatedPtrField< ::larpc::RPCResponse >* mutable_responses();
  inline const ::larpc::RPCResponse& responses(int index) const;
  inline ::larpc::RPCResponse* mutable_responses(int index);
  inline ::larpc::RPCResponse* add_responses();
  
  // optional .larpc.ChannelControl control = 3;
  inline bool has_control() const;
  inline void clear_control();
  static const int kControlFieldNumber = 3;
  inline const ::larpc::ChannelControl& control() const;
  inline ::larpc::ChannelControl* mutable_control();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::larpc::RPCRequest > requests_;
  ::google::protobuf::RepeatedPtrField< ::larpc::RPCResponse > responses_;
  ::larpc::ChannelControl* control_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ChannelMessage* default_instance_;
};
// -------------------------------------------------------------------

class ChannelSetup : public ::google::protobuf::Message {
 public:
  ChannelSetup();
  virtual ~ChannelSetup();
  
  ChannelSetup(const ChannelSetup& from);
  
  inline ChannelSetup& operator=(const ChannelSetup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelSetup& default_instance();
  void Swap(ChannelSetup* other);
  
  // implements Message ----------------------------------------------
  
  ChannelSetup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChannelSetup& from);
  void MergeFrom(const ChannelSetup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string machine_id = 1;
  inline bool has_machine_id() const;
  inline void clear_machine_id();
  static const int kMachineIdFieldNumber = 1;
  inline const ::std::string& machine_id() const;
  inline void set_machine_id(const ::std::string& value);
  inline void set_machine_id(const char* value);
  inline void set_machine_id(const char* value, size_t size);
  inline ::std::string* mutable_machine_id();
  
  // repeated .larpc.PrincipleDescriptor principles = 2;
  inline int principles_size() const;
  inline void clear_principles();
  static const int kPrinciplesFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleDescriptor >& principles() const;
  inline ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleDescriptor >* mutable_principles();
  inline const ::larpc::PrincipleDescriptor& principles(int index) const;
  inline ::larpc::PrincipleDescriptor* mutable_principles(int index);
  inline ::larpc::PrincipleDescriptor* add_principles();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* machine_id_;
  static const ::std::string _default_machine_id_;
  ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleDescriptor > principles_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ChannelSetup* default_instance_;
};
// -------------------------------------------------------------------

class PrincipleVersionRecord : public ::google::protobuf::Message {
 public:
  PrincipleVersionRecord();
  virtual ~PrincipleVersionRecord();
  
  PrincipleVersionRecord(const PrincipleVersionRecord& from);
  
  inline PrincipleVersionRecord& operator=(const PrincipleVersionRecord& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrincipleVersionRecord& default_instance();
  void Swap(PrincipleVersionRecord* other);
  
  // implements Message ----------------------------------------------
  
  PrincipleVersionRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrincipleVersionRecord& from);
  void MergeFrom(const PrincipleVersionRecord& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);
  
  // required string hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 version_;
  ::std::string* hash_;
  static const ::std::string _default_hash_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PrincipleVersionRecord* default_instance_;
};
// -------------------------------------------------------------------

class PrincipleDescriptor : public ::google::protobuf::Message {
 public:
  PrincipleDescriptor();
  virtual ~PrincipleDescriptor();
  
  PrincipleDescriptor(const PrincipleDescriptor& from);
  
  inline PrincipleDescriptor& operator=(const PrincipleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrincipleDescriptor& default_instance();
  void Swap(PrincipleDescriptor* other);
  
  // implements Message ----------------------------------------------
  
  PrincipleDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrincipleDescriptor& from);
  void MergeFrom(const PrincipleDescriptor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string display_name = 1;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 1;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  
  // required string public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const char* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required uint32 version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);
  
  // repeated string trusting_x509_certificate = 4;
  inline int trusting_x509_certificate_size() const;
  inline void clear_trusting_x509_certificate();
  static const int kTrustingX509CertificateFieldNumber = 4;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& trusting_x509_certificate() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_trusting_x509_certificate();
  inline const ::std::string& trusting_x509_certificate(int index) const;
  inline ::std::string* mutable_trusting_x509_certificate(int index);
  inline void set_trusting_x509_certificate(int index, const ::std::string& value);
  inline void set_trusting_x509_certificate(int index, const char* value);
  inline void set_trusting_x509_certificate(int index, const char* value, size_t size);
  inline ::std::string* add_trusting_x509_certificate();
  inline void add_trusting_x509_certificate(const ::std::string& value);
  inline void add_trusting_x509_certificate(const char* value);
  inline void add_trusting_x509_certificate(const char* value, size_t size);
  
  // optional string encrypted_private_key = 6;
  inline bool has_encrypted_private_key() const;
  inline void clear_encrypted_private_key();
  static const int kEncryptedPrivateKeyFieldNumber = 6;
  inline const ::std::string& encrypted_private_key() const;
  inline void set_encrypted_private_key(const ::std::string& value);
  inline void set_encrypted_private_key(const char* value);
  inline void set_encrypted_private_key(const char* value, size_t size);
  inline ::std::string* mutable_encrypted_private_key();
  
  // optional .larpc.EncryptionDescriptor private_key_encryption_descriptor = 7;
  inline bool has_private_key_encryption_descriptor() const;
  inline void clear_private_key_encryption_descriptor();
  static const int kPrivateKeyEncryptionDescriptorFieldNumber = 7;
  inline const ::larpc::EncryptionDescriptor& private_key_encryption_descriptor() const;
  inline ::larpc::EncryptionDescriptor* mutable_private_key_encryption_descriptor();
  
  // repeated .larpc.PrincipleVersionRecord past_versions = 8;
  inline int past_versions_size() const;
  inline void clear_past_versions();
  static const int kPastVersionsFieldNumber = 8;
  inline const ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleVersionRecord >& past_versions() const;
  inline ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleVersionRecord >* mutable_past_versions();
  inline const ::larpc::PrincipleVersionRecord& past_versions(int index) const;
  inline ::larpc::PrincipleVersionRecord* mutable_past_versions(int index);
  inline ::larpc::PrincipleVersionRecord* add_past_versions();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* display_name_;
  static const ::std::string _default_display_name_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> trusting_x509_certificate_;
  ::std::string* encrypted_private_key_;
  static const ::std::string _default_encrypted_private_key_;
  ::larpc::EncryptionDescriptor* private_key_encryption_descriptor_;
  ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleVersionRecord > past_versions_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PrincipleDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class MethodDescriptor : public ::google::protobuf::Message {
 public:
  MethodDescriptor();
  virtual ~MethodDescriptor();
  
  MethodDescriptor(const MethodDescriptor& from);
  
  inline MethodDescriptor& operator=(const MethodDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MethodDescriptor& default_instance();
  void Swap(MethodDescriptor* other);
  
  // implements Message ----------------------------------------------
  
  MethodDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MethodDescriptor& from);
  void MergeFrom(const MethodDescriptor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string method_name = 1;
  inline bool has_method_name() const;
  inline void clear_method_name();
  static const int kMethodNameFieldNumber = 1;
  inline const ::std::string& method_name() const;
  inline void set_method_name(const ::std::string& value);
  inline void set_method_name(const char* value);
  inline void set_method_name(const char* value, size_t size);
  inline ::std::string* mutable_method_name();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* method_name_;
  static const ::std::string _default_method_name_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MethodDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class RPCRequest : public ::google::protobuf::Message {
 public:
  RPCRequest();
  virtual ~RPCRequest();
  
  RPCRequest(const RPCRequest& from);
  
  inline RPCRequest& operator=(const RPCRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCRequest& default_instance();
  void Swap(RPCRequest* other);
  
  // implements Message ----------------------------------------------
  
  RPCRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCRequest& from);
  void MergeFrom(const RPCRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_id();
  
  // optional uint32 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint32 request_id() const;
  inline void set_request_id(::google::protobuf::uint32 value);
  
  // optional .larpc.MethodDescriptor method_id = 3;
  inline bool has_method_id() const;
  inline void clear_method_id();
  static const int kMethodIdFieldNumber = 3;
  inline const ::larpc::MethodDescriptor& method_id() const;
  inline ::larpc::MethodDescriptor* mutable_method_id();
  
  // optional bytes method_parameters = 4;
  inline bool has_method_parameters() const;
  inline void clear_method_parameters();
  static const int kMethodParametersFieldNumber = 4;
  inline const ::std::string& method_parameters() const;
  inline void set_method_parameters(const ::std::string& value);
  inline void set_method_parameters(const char* value);
  inline void set_method_parameters(const void* value, size_t size);
  inline ::std::string* mutable_method_parameters();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* channel_id_;
  static const ::std::string _default_channel_id_;
  ::google::protobuf::uint32 request_id_;
  ::larpc::MethodDescriptor* method_id_;
  ::std::string* method_parameters_;
  static const ::std::string _default_method_parameters_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RPCRequest* default_instance_;
};
// -------------------------------------------------------------------

class RPCResponse : public ::google::protobuf::Message {
 public:
  RPCResponse();
  virtual ~RPCResponse();
  
  RPCResponse(const RPCResponse& from);
  
  inline RPCResponse& operator=(const RPCResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCResponse& default_instance();
  void Swap(RPCResponse* other);
  
  // implements Message ----------------------------------------------
  
  RPCResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCResponse& from);
  void MergeFrom(const RPCResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string channel_id = 1;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_id();
  
  // optional uint32 request_id = 2;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  inline ::google::protobuf::uint32 request_id() const;
  inline void set_request_id(::google::protobuf::uint32 value);
  
  // optional bytes response = 3;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 3;
  inline const ::std::string& response() const;
  inline void set_response(const ::std::string& value);
  inline void set_response(const char* value);
  inline void set_response(const void* value, size_t size);
  inline ::std::string* mutable_response();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* channel_id_;
  static const ::std::string _default_channel_id_;
  ::google::protobuf::uint32 request_id_;
  ::std::string* response_;
  static const ::std::string _default_response_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RPCResponse* default_instance_;
};
// -------------------------------------------------------------------

class OpenChannelRequest : public ::google::protobuf::Message {
 public:
  OpenChannelRequest();
  virtual ~OpenChannelRequest();
  
  OpenChannelRequest(const OpenChannelRequest& from);
  
  inline OpenChannelRequest& operator=(const OpenChannelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenChannelRequest& default_instance();
  void Swap(OpenChannelRequest* other);
  
  // implements Message ----------------------------------------------
  
  OpenChannelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenChannelRequest& from);
  void MergeFrom(const OpenChannelRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes initiator_public_key = 1;
  inline bool has_initiator_public_key() const;
  inline void clear_initiator_public_key();
  static const int kInitiatorPublicKeyFieldNumber = 1;
  inline const ::std::string& initiator_public_key() const;
  inline void set_initiator_public_key(const ::std::string& value);
  inline void set_initiator_public_key(const char* value);
  inline void set_initiator_public_key(const void* value, size_t size);
  inline ::std::string* mutable_initiator_public_key();
  
  // optional bytes initiator_certificate = 2;
  inline bool has_initiator_certificate() const;
  inline void clear_initiator_certificate();
  static const int kInitiatorCertificateFieldNumber = 2;
  inline const ::std::string& initiator_certificate() const;
  inline void set_initiator_certificate(const ::std::string& value);
  inline void set_initiator_certificate(const char* value);
  inline void set_initiator_certificate(const void* value, size_t size);
  inline ::std::string* mutable_initiator_certificate();
  
  // optional .larpc.PrincipleDescriptor desired_principle = 3;
  inline bool has_desired_principle() const;
  inline void clear_desired_principle();
  static const int kDesiredPrincipleFieldNumber = 3;
  inline const ::larpc::PrincipleDescriptor& desired_principle() const;
  inline ::larpc::PrincipleDescriptor* mutable_desired_principle();
  
  // optional string channel_id = 4;
  inline bool has_channel_id() const;
  inline void clear_channel_id();
  static const int kChannelIdFieldNumber = 4;
  inline const ::std::string& channel_id() const;
  inline void set_channel_id(const ::std::string& value);
  inline void set_channel_id(const char* value);
  inline void set_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_channel_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* initiator_public_key_;
  static const ::std::string _default_initiator_public_key_;
  ::std::string* initiator_certificate_;
  static const ::std::string _default_initiator_certificate_;
  ::larpc::PrincipleDescriptor* desired_principle_;
  ::std::string* channel_id_;
  static const ::std::string _default_channel_id_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OpenChannelRequest* default_instance_;
};
// -------------------------------------------------------------------

class OpenChannelResponse : public ::google::protobuf::Message {
 public:
  OpenChannelResponse();
  virtual ~OpenChannelResponse();
  
  OpenChannelResponse(const OpenChannelResponse& from);
  
  inline OpenChannelResponse& operator=(const OpenChannelResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenChannelResponse& default_instance();
  void Swap(OpenChannelResponse* other);
  
  // implements Message ----------------------------------------------
  
  OpenChannelResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenChannelResponse& from);
  void MergeFrom(const OpenChannelResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string initiator_channel_id = 1;
  inline bool has_initiator_channel_id() const;
  inline void clear_initiator_channel_id();
  static const int kInitiatorChannelIdFieldNumber = 1;
  inline const ::std::string& initiator_channel_id() const;
  inline void set_initiator_channel_id(const ::std::string& value);
  inline void set_initiator_channel_id(const char* value);
  inline void set_initiator_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_initiator_channel_id();
  
  // optional string responding_channel_id = 2;
  inline bool has_responding_channel_id() const;
  inline void clear_responding_channel_id();
  static const int kRespondingChannelIdFieldNumber = 2;
  inline const ::std::string& responding_channel_id() const;
  inline void set_responding_channel_id(const ::std::string& value);
  inline void set_responding_channel_id(const char* value);
  inline void set_responding_channel_id(const char* value, size_t size);
  inline ::std::string* mutable_responding_channel_id();
  
  // optional bytes responding_certificate = 3;
  inline bool has_responding_certificate() const;
  inline void clear_responding_certificate();
  static const int kRespondingCertificateFieldNumber = 3;
  inline const ::std::string& responding_certificate() const;
  inline void set_responding_certificate(const ::std::string& value);
  inline void set_responding_certificate(const char* value);
  inline void set_responding_certificate(const void* value, size_t size);
  inline ::std::string* mutable_responding_certificate();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* initiator_channel_id_;
  static const ::std::string _default_initiator_channel_id_;
  ::std::string* responding_channel_id_;
  static const ::std::string _default_responding_channel_id_;
  ::std::string* responding_certificate_;
  static const ::std::string _default_responding_certificate_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OpenChannelResponse* default_instance_;
};
// -------------------------------------------------------------------

class ChannelControl : public ::google::protobuf::Message {
 public:
  ChannelControl();
  virtual ~ChannelControl();
  
  ChannelControl(const ChannelControl& from);
  
  inline ChannelControl& operator=(const ChannelControl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChannelControl& default_instance();
  void Swap(ChannelControl* other);
  
  // implements Message ----------------------------------------------
  
  ChannelControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChannelControl& from);
  void MergeFrom(const ChannelControl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .larpc.OpenChannelRequest open_channel_request = 1;
  inline int open_channel_request_size() const;
  inline void clear_open_channel_request();
  static const int kOpenChannelRequestFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelRequest >& open_channel_request() const;
  inline ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelRequest >* mutable_open_channel_request();
  inline const ::larpc::OpenChannelRequest& open_channel_request(int index) const;
  inline ::larpc::OpenChannelRequest* mutable_open_channel_request(int index);
  inline ::larpc::OpenChannelRequest* add_open_channel_request();
  
  // repeated .larpc.OpenChannelResponse open_channel_response = 2;
  inline int open_channel_response_size() const;
  inline void clear_open_channel_response();
  static const int kOpenChannelResponseFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelResponse >& open_channel_response() const;
  inline ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelResponse >* mutable_open_channel_response();
  inline const ::larpc::OpenChannelResponse& open_channel_response(int index) const;
  inline ::larpc::OpenChannelResponse* mutable_open_channel_response(int index);
  inline ::larpc::OpenChannelResponse* add_open_channel_response();
  
  // repeated string close_channel_id = 3;
  inline int close_channel_id_size() const;
  inline void clear_close_channel_id();
  static const int kCloseChannelIdFieldNumber = 3;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& close_channel_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_close_channel_id();
  inline const ::std::string& close_channel_id(int index) const;
  inline ::std::string* mutable_close_channel_id(int index);
  inline void set_close_channel_id(int index, const ::std::string& value);
  inline void set_close_channel_id(int index, const char* value);
  inline void set_close_channel_id(int index, const char* value, size_t size);
  inline ::std::string* add_close_channel_id();
  inline void add_close_channel_id(const ::std::string& value);
  inline void add_close_channel_id(const char* value);
  inline void add_close_channel_id(const char* value, size_t size);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelRequest > open_channel_request_;
  ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelResponse > open_channel_response_;
  ::google::protobuf::RepeatedPtrField< ::std::string> close_channel_id_;
  friend void  protobuf_AddDesc_larpc_2eproto();
  friend void protobuf_AssignDesc_larpc_2eproto();
  friend void protobuf_ShutdownFile_larpc_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ChannelControl* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// EncryptionDescriptor

// optional string cipher = 1;
inline bool EncryptionDescriptor::has_cipher() const {
  return _has_bit(0);
}
inline void EncryptionDescriptor::clear_cipher() {
  if (cipher_ != &_default_cipher_) {
    cipher_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& EncryptionDescriptor::cipher() const {
  return *cipher_;
}
inline void EncryptionDescriptor::set_cipher(const ::std::string& value) {
  _set_bit(0);
  if (cipher_ == &_default_cipher_) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(value);
}
inline void EncryptionDescriptor::set_cipher(const char* value) {
  _set_bit(0);
  if (cipher_ == &_default_cipher_) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(value);
}
inline void EncryptionDescriptor::set_cipher(const char* value, size_t size) {
  _set_bit(0);
  if (cipher_ == &_default_cipher_) {
    cipher_ = new ::std::string;
  }
  cipher_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptionDescriptor::mutable_cipher() {
  _set_bit(0);
  if (cipher_ == &_default_cipher_) {
    cipher_ = new ::std::string;
  }
  return cipher_;
}

// optional string key = 2;
inline bool EncryptionDescriptor::has_key() const {
  return _has_bit(1);
}
inline void EncryptionDescriptor::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& EncryptionDescriptor::key() const {
  return *key_;
}
inline void EncryptionDescriptor::set_key(const ::std::string& value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void EncryptionDescriptor::set_key(const char* value) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void EncryptionDescriptor::set_key(const char* value, size_t size) {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptionDescriptor::mutable_key() {
  _set_bit(1);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional string iv = 3;
inline bool EncryptionDescriptor::has_iv() const {
  return _has_bit(2);
}
inline void EncryptionDescriptor::clear_iv() {
  if (iv_ != &_default_iv_) {
    iv_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& EncryptionDescriptor::iv() const {
  return *iv_;
}
inline void EncryptionDescriptor::set_iv(const ::std::string& value) {
  _set_bit(2);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void EncryptionDescriptor::set_iv(const char* value) {
  _set_bit(2);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  iv_->assign(value);
}
inline void EncryptionDescriptor::set_iv(const char* value, size_t size) {
  _set_bit(2);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  iv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptionDescriptor::mutable_iv() {
  _set_bit(2);
  if (iv_ == &_default_iv_) {
    iv_ = new ::std::string;
  }
  return iv_;
}

// optional bool is_password_based = 4 [default = false];
inline bool EncryptionDescriptor::has_is_password_based() const {
  return _has_bit(3);
}
inline void EncryptionDescriptor::clear_is_password_based() {
  is_password_based_ = false;
  _clear_bit(3);
}
inline bool EncryptionDescriptor::is_password_based() const {
  return is_password_based_;
}
inline void EncryptionDescriptor::set_is_password_based(bool value) {
  _set_bit(3);
  is_password_based_ = value;
}

// optional string password_digest_algorithm = 5;
inline bool EncryptionDescriptor::has_password_digest_algorithm() const {
  return _has_bit(4);
}
inline void EncryptionDescriptor::clear_password_digest_algorithm() {
  if (password_digest_algorithm_ != &_default_password_digest_algorithm_) {
    password_digest_algorithm_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& EncryptionDescriptor::password_digest_algorithm() const {
  return *password_digest_algorithm_;
}
inline void EncryptionDescriptor::set_password_digest_algorithm(const ::std::string& value) {
  _set_bit(4);
  if (password_digest_algorithm_ == &_default_password_digest_algorithm_) {
    password_digest_algorithm_ = new ::std::string;
  }
  password_digest_algorithm_->assign(value);
}
inline void EncryptionDescriptor::set_password_digest_algorithm(const char* value) {
  _set_bit(4);
  if (password_digest_algorithm_ == &_default_password_digest_algorithm_) {
    password_digest_algorithm_ = new ::std::string;
  }
  password_digest_algorithm_->assign(value);
}
inline void EncryptionDescriptor::set_password_digest_algorithm(const char* value, size_t size) {
  _set_bit(4);
  if (password_digest_algorithm_ == &_default_password_digest_algorithm_) {
    password_digest_algorithm_ = new ::std::string;
  }
  password_digest_algorithm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptionDescriptor::mutable_password_digest_algorithm() {
  _set_bit(4);
  if (password_digest_algorithm_ == &_default_password_digest_algorithm_) {
    password_digest_algorithm_ = new ::std::string;
  }
  return password_digest_algorithm_;
}

// optional string key_hash = 6;
inline bool EncryptionDescriptor::has_key_hash() const {
  return _has_bit(5);
}
inline void EncryptionDescriptor::clear_key_hash() {
  if (key_hash_ != &_default_key_hash_) {
    key_hash_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& EncryptionDescriptor::key_hash() const {
  return *key_hash_;
}
inline void EncryptionDescriptor::set_key_hash(const ::std::string& value) {
  _set_bit(5);
  if (key_hash_ == &_default_key_hash_) {
    key_hash_ = new ::std::string;
  }
  key_hash_->assign(value);
}
inline void EncryptionDescriptor::set_key_hash(const char* value) {
  _set_bit(5);
  if (key_hash_ == &_default_key_hash_) {
    key_hash_ = new ::std::string;
  }
  key_hash_->assign(value);
}
inline void EncryptionDescriptor::set_key_hash(const char* value, size_t size) {
  _set_bit(5);
  if (key_hash_ == &_default_key_hash_) {
    key_hash_ = new ::std::string;
  }
  key_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptionDescriptor::mutable_key_hash() {
  _set_bit(5);
  if (key_hash_ == &_default_key_hash_) {
    key_hash_ = new ::std::string;
  }
  return key_hash_;
}

// -------------------------------------------------------------------

// KeygenParameters

// required string key_type = 1;
inline bool KeygenParameters::has_key_type() const {
  return _has_bit(0);
}
inline void KeygenParameters::clear_key_type() {
  if (key_type_ != &_default_key_type_) {
    key_type_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& KeygenParameters::key_type() const {
  return *key_type_;
}
inline void KeygenParameters::set_key_type(const ::std::string& value) {
  _set_bit(0);
  if (key_type_ == &_default_key_type_) {
    key_type_ = new ::std::string;
  }
  key_type_->assign(value);
}
inline void KeygenParameters::set_key_type(const char* value) {
  _set_bit(0);
  if (key_type_ == &_default_key_type_) {
    key_type_ = new ::std::string;
  }
  key_type_->assign(value);
}
inline void KeygenParameters::set_key_type(const char* value, size_t size) {
  _set_bit(0);
  if (key_type_ == &_default_key_type_) {
    key_type_ = new ::std::string;
  }
  key_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeygenParameters::mutable_key_type() {
  _set_bit(0);
  if (key_type_ == &_default_key_type_) {
    key_type_ = new ::std::string;
  }
  return key_type_;
}

// optional uint32 num_bits = 2;
inline bool KeygenParameters::has_num_bits() const {
  return _has_bit(1);
}
inline void KeygenParameters::clear_num_bits() {
  num_bits_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 KeygenParameters::num_bits() const {
  return num_bits_;
}
inline void KeygenParameters::set_num_bits(::google::protobuf::uint32 value) {
  _set_bit(1);
  num_bits_ = value;
}

// -------------------------------------------------------------------

// MachineKey

// required string public_key = 1;
inline bool MachineKey::has_public_key() const {
  return _has_bit(0);
}
inline void MachineKey::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MachineKey::public_key() const {
  return *public_key_;
}
inline void MachineKey::set_public_key(const ::std::string& value) {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void MachineKey::set_public_key(const char* value) {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void MachineKey::set_public_key(const char* value, size_t size) {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MachineKey::mutable_public_key() {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required string private_key = 2;
inline bool MachineKey::has_private_key() const {
  return _has_bit(1);
}
inline void MachineKey::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MachineKey::private_key() const {
  return *private_key_;
}
inline void MachineKey::set_private_key(const ::std::string& value) {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void MachineKey::set_private_key(const char* value) {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void MachineKey::set_private_key(const char* value, size_t size) {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MachineKey::mutable_private_key() {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// -------------------------------------------------------------------

// Config

// required string machine_key_file = 1;
inline bool Config::has_machine_key_file() const {
  return _has_bit(0);
}
inline void Config::clear_machine_key_file() {
  if (machine_key_file_ != &_default_machine_key_file_) {
    machine_key_file_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Config::machine_key_file() const {
  return *machine_key_file_;
}
inline void Config::set_machine_key_file(const ::std::string& value) {
  _set_bit(0);
  if (machine_key_file_ == &_default_machine_key_file_) {
    machine_key_file_ = new ::std::string;
  }
  machine_key_file_->assign(value);
}
inline void Config::set_machine_key_file(const char* value) {
  _set_bit(0);
  if (machine_key_file_ == &_default_machine_key_file_) {
    machine_key_file_ = new ::std::string;
  }
  machine_key_file_->assign(value);
}
inline void Config::set_machine_key_file(const char* value, size_t size) {
  _set_bit(0);
  if (machine_key_file_ == &_default_machine_key_file_) {
    machine_key_file_ = new ::std::string;
  }
  machine_key_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Config::mutable_machine_key_file() {
  _set_bit(0);
  if (machine_key_file_ == &_default_machine_key_file_) {
    machine_key_file_ = new ::std::string;
  }
  return machine_key_file_;
}

// optional .larpc.EncryptionDescriptor machine_key_encryption = 2;
inline bool Config::has_machine_key_encryption() const {
  return _has_bit(1);
}
inline void Config::clear_machine_key_encryption() {
  if (machine_key_encryption_ != NULL) machine_key_encryption_->::larpc::EncryptionDescriptor::Clear();
  _clear_bit(1);
}
inline const ::larpc::EncryptionDescriptor& Config::machine_key_encryption() const {
  return machine_key_encryption_ != NULL ? *machine_key_encryption_ : *default_instance_->machine_key_encryption_;
}
inline ::larpc::EncryptionDescriptor* Config::mutable_machine_key_encryption() {
  _set_bit(1);
  if (machine_key_encryption_ == NULL) machine_key_encryption_ = new ::larpc::EncryptionDescriptor;
  return machine_key_encryption_;
}

// required string local_principles_file = 3;
inline bool Config::has_local_principles_file() const {
  return _has_bit(2);
}
inline void Config::clear_local_principles_file() {
  if (local_principles_file_ != &_default_local_principles_file_) {
    local_principles_file_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Config::local_principles_file() const {
  return *local_principles_file_;
}
inline void Config::set_local_principles_file(const ::std::string& value) {
  _set_bit(2);
  if (local_principles_file_ == &_default_local_principles_file_) {
    local_principles_file_ = new ::std::string;
  }
  local_principles_file_->assign(value);
}
inline void Config::set_local_principles_file(const char* value) {
  _set_bit(2);
  if (local_principles_file_ == &_default_local_principles_file_) {
    local_principles_file_ = new ::std::string;
  }
  local_principles_file_->assign(value);
}
inline void Config::set_local_principles_file(const char* value, size_t size) {
  _set_bit(2);
  if (local_principles_file_ == &_default_local_principles_file_) {
    local_principles_file_ = new ::std::string;
  }
  local_principles_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Config::mutable_local_principles_file() {
  _set_bit(2);
  if (local_principles_file_ == &_default_local_principles_file_) {
    local_principles_file_ = new ::std::string;
  }
  return local_principles_file_;
}

// required string bind_ip = 4;
inline bool Config::has_bind_ip() const {
  return _has_bit(3);
}
inline void Config::clear_bind_ip() {
  if (bind_ip_ != &_default_bind_ip_) {
    bind_ip_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Config::bind_ip() const {
  return *bind_ip_;
}
inline void Config::set_bind_ip(const ::std::string& value) {
  _set_bit(3);
  if (bind_ip_ == &_default_bind_ip_) {
    bind_ip_ = new ::std::string;
  }
  bind_ip_->assign(value);
}
inline void Config::set_bind_ip(const char* value) {
  _set_bit(3);
  if (bind_ip_ == &_default_bind_ip_) {
    bind_ip_ = new ::std::string;
  }
  bind_ip_->assign(value);
}
inline void Config::set_bind_ip(const char* value, size_t size) {
  _set_bit(3);
  if (bind_ip_ == &_default_bind_ip_) {
    bind_ip_ = new ::std::string;
  }
  bind_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Config::mutable_bind_ip() {
  _set_bit(3);
  if (bind_ip_ == &_default_bind_ip_) {
    bind_ip_ = new ::std::string;
  }
  return bind_ip_;
}

// required int32 bind_port = 5;
inline bool Config::has_bind_port() const {
  return _has_bit(4);
}
inline void Config::clear_bind_port() {
  bind_port_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 Config::bind_port() const {
  return bind_port_;
}
inline void Config::set_bind_port(::google::protobuf::int32 value) {
  _set_bit(4);
  bind_port_ = value;
}

// required string trust_certificate_issuer_cn = 6;
inline bool Config::has_trust_certificate_issuer_cn() const {
  return _has_bit(5);
}
inline void Config::clear_trust_certificate_issuer_cn() {
  if (trust_certificate_issuer_cn_ != &_default_trust_certificate_issuer_cn_) {
    trust_certificate_issuer_cn_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Config::trust_certificate_issuer_cn() const {
  return *trust_certificate_issuer_cn_;
}
inline void Config::set_trust_certificate_issuer_cn(const ::std::string& value) {
  _set_bit(5);
  if (trust_certificate_issuer_cn_ == &_default_trust_certificate_issuer_cn_) {
    trust_certificate_issuer_cn_ = new ::std::string;
  }
  trust_certificate_issuer_cn_->assign(value);
}
inline void Config::set_trust_certificate_issuer_cn(const char* value) {
  _set_bit(5);
  if (trust_certificate_issuer_cn_ == &_default_trust_certificate_issuer_cn_) {
    trust_certificate_issuer_cn_ = new ::std::string;
  }
  trust_certificate_issuer_cn_->assign(value);
}
inline void Config::set_trust_certificate_issuer_cn(const char* value, size_t size) {
  _set_bit(5);
  if (trust_certificate_issuer_cn_ == &_default_trust_certificate_issuer_cn_) {
    trust_certificate_issuer_cn_ = new ::std::string;
  }
  trust_certificate_issuer_cn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Config::mutable_trust_certificate_issuer_cn() {
  _set_bit(5);
  if (trust_certificate_issuer_cn_ == &_default_trust_certificate_issuer_cn_) {
    trust_certificate_issuer_cn_ = new ::std::string;
  }
  return trust_certificate_issuer_cn_;
}

// required int32 trust_certificate_expiration_time_days = 7;
inline bool Config::has_trust_certificate_expiration_time_days() const {
  return _has_bit(6);
}
inline void Config::clear_trust_certificate_expiration_time_days() {
  trust_certificate_expiration_time_days_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 Config::trust_certificate_expiration_time_days() const {
  return trust_certificate_expiration_time_days_;
}
inline void Config::set_trust_certificate_expiration_time_days(::google::protobuf::int32 value) {
  _set_bit(6);
  trust_certificate_expiration_time_days_ = value;
}

// -------------------------------------------------------------------

// ChannelMessage

// repeated .larpc.RPCRequest requests = 1;
inline int ChannelMessage::requests_size() const {
  return requests_.size();
}
inline void ChannelMessage::clear_requests() {
  requests_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::larpc::RPCRequest >&
ChannelMessage::requests() const {
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::larpc::RPCRequest >*
ChannelMessage::mutable_requests() {
  return &requests_;
}
inline const ::larpc::RPCRequest& ChannelMessage::requests(int index) const {
  return requests_.Get(index);
}
inline ::larpc::RPCRequest* ChannelMessage::mutable_requests(int index) {
  return requests_.Mutable(index);
}
inline ::larpc::RPCRequest* ChannelMessage::add_requests() {
  return requests_.Add();
}

// repeated .larpc.RPCResponse responses = 2;
inline int ChannelMessage::responses_size() const {
  return responses_.size();
}
inline void ChannelMessage::clear_responses() {
  responses_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::larpc::RPCResponse >&
ChannelMessage::responses() const {
  return responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::larpc::RPCResponse >*
ChannelMessage::mutable_responses() {
  return &responses_;
}
inline const ::larpc::RPCResponse& ChannelMessage::responses(int index) const {
  return responses_.Get(index);
}
inline ::larpc::RPCResponse* ChannelMessage::mutable_responses(int index) {
  return responses_.Mutable(index);
}
inline ::larpc::RPCResponse* ChannelMessage::add_responses() {
  return responses_.Add();
}

// optional .larpc.ChannelControl control = 3;
inline bool ChannelMessage::has_control() const {
  return _has_bit(2);
}
inline void ChannelMessage::clear_control() {
  if (control_ != NULL) control_->::larpc::ChannelControl::Clear();
  _clear_bit(2);
}
inline const ::larpc::ChannelControl& ChannelMessage::control() const {
  return control_ != NULL ? *control_ : *default_instance_->control_;
}
inline ::larpc::ChannelControl* ChannelMessage::mutable_control() {
  _set_bit(2);
  if (control_ == NULL) control_ = new ::larpc::ChannelControl;
  return control_;
}

// -------------------------------------------------------------------

// ChannelSetup

// required string machine_id = 1;
inline bool ChannelSetup::has_machine_id() const {
  return _has_bit(0);
}
inline void ChannelSetup::clear_machine_id() {
  if (machine_id_ != &_default_machine_id_) {
    machine_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ChannelSetup::machine_id() const {
  return *machine_id_;
}
inline void ChannelSetup::set_machine_id(const ::std::string& value) {
  _set_bit(0);
  if (machine_id_ == &_default_machine_id_) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ChannelSetup::set_machine_id(const char* value) {
  _set_bit(0);
  if (machine_id_ == &_default_machine_id_) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(value);
}
inline void ChannelSetup::set_machine_id(const char* value, size_t size) {
  _set_bit(0);
  if (machine_id_ == &_default_machine_id_) {
    machine_id_ = new ::std::string;
  }
  machine_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChannelSetup::mutable_machine_id() {
  _set_bit(0);
  if (machine_id_ == &_default_machine_id_) {
    machine_id_ = new ::std::string;
  }
  return machine_id_;
}

// repeated .larpc.PrincipleDescriptor principles = 2;
inline int ChannelSetup::principles_size() const {
  return principles_.size();
}
inline void ChannelSetup::clear_principles() {
  principles_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleDescriptor >&
ChannelSetup::principles() const {
  return principles_;
}
inline ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleDescriptor >*
ChannelSetup::mutable_principles() {
  return &principles_;
}
inline const ::larpc::PrincipleDescriptor& ChannelSetup::principles(int index) const {
  return principles_.Get(index);
}
inline ::larpc::PrincipleDescriptor* ChannelSetup::mutable_principles(int index) {
  return principles_.Mutable(index);
}
inline ::larpc::PrincipleDescriptor* ChannelSetup::add_principles() {
  return principles_.Add();
}

// -------------------------------------------------------------------

// PrincipleVersionRecord

// required uint32 version = 1;
inline bool PrincipleVersionRecord::has_version() const {
  return _has_bit(0);
}
inline void PrincipleVersionRecord::clear_version() {
  version_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 PrincipleVersionRecord::version() const {
  return version_;
}
inline void PrincipleVersionRecord::set_version(::google::protobuf::uint32 value) {
  _set_bit(0);
  version_ = value;
}

// required string hash = 2;
inline bool PrincipleVersionRecord::has_hash() const {
  return _has_bit(1);
}
inline void PrincipleVersionRecord::clear_hash() {
  if (hash_ != &_default_hash_) {
    hash_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PrincipleVersionRecord::hash() const {
  return *hash_;
}
inline void PrincipleVersionRecord::set_hash(const ::std::string& value) {
  _set_bit(1);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void PrincipleVersionRecord::set_hash(const char* value) {
  _set_bit(1);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void PrincipleVersionRecord::set_hash(const char* value, size_t size) {
  _set_bit(1);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrincipleVersionRecord::mutable_hash() {
  _set_bit(1);
  if (hash_ == &_default_hash_) {
    hash_ = new ::std::string;
  }
  return hash_;
}

// -------------------------------------------------------------------

// PrincipleDescriptor

// required string display_name = 1;
inline bool PrincipleDescriptor::has_display_name() const {
  return _has_bit(0);
}
inline void PrincipleDescriptor::clear_display_name() {
  if (display_name_ != &_default_display_name_) {
    display_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PrincipleDescriptor::display_name() const {
  return *display_name_;
}
inline void PrincipleDescriptor::set_display_name(const ::std::string& value) {
  _set_bit(0);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void PrincipleDescriptor::set_display_name(const char* value) {
  _set_bit(0);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void PrincipleDescriptor::set_display_name(const char* value, size_t size) {
  _set_bit(0);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrincipleDescriptor::mutable_display_name() {
  _set_bit(0);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}

// required string public_key = 2;
inline bool PrincipleDescriptor::has_public_key() const {
  return _has_bit(1);
}
inline void PrincipleDescriptor::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PrincipleDescriptor::public_key() const {
  return *public_key_;
}
inline void PrincipleDescriptor::set_public_key(const ::std::string& value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void PrincipleDescriptor::set_public_key(const char* value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void PrincipleDescriptor::set_public_key(const char* value, size_t size) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrincipleDescriptor::mutable_public_key() {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required uint32 version = 3;
inline bool PrincipleDescriptor::has_version() const {
  return _has_bit(2);
}
inline void PrincipleDescriptor::clear_version() {
  version_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 PrincipleDescriptor::version() const {
  return version_;
}
inline void PrincipleDescriptor::set_version(::google::protobuf::uint32 value) {
  _set_bit(2);
  version_ = value;
}

// repeated string trusting_x509_certificate = 4;
inline int PrincipleDescriptor::trusting_x509_certificate_size() const {
  return trusting_x509_certificate_.size();
}
inline void PrincipleDescriptor::clear_trusting_x509_certificate() {
  trusting_x509_certificate_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PrincipleDescriptor::trusting_x509_certificate() const {
  return trusting_x509_certificate_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PrincipleDescriptor::mutable_trusting_x509_certificate() {
  return &trusting_x509_certificate_;
}
inline const ::std::string& PrincipleDescriptor::trusting_x509_certificate(int index) const {
  return trusting_x509_certificate_.Get(index);
}
inline ::std::string* PrincipleDescriptor::mutable_trusting_x509_certificate(int index) {
  return trusting_x509_certificate_.Mutable(index);
}
inline void PrincipleDescriptor::set_trusting_x509_certificate(int index, const ::std::string& value) {
  trusting_x509_certificate_.Mutable(index)->assign(value);
}
inline void PrincipleDescriptor::set_trusting_x509_certificate(int index, const char* value) {
  trusting_x509_certificate_.Mutable(index)->assign(value);
}
inline void PrincipleDescriptor::set_trusting_x509_certificate(int index, const char* value, size_t size) {
  trusting_x509_certificate_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrincipleDescriptor::add_trusting_x509_certificate() {
  return trusting_x509_certificate_.Add();
}
inline void PrincipleDescriptor::add_trusting_x509_certificate(const ::std::string& value) {
  trusting_x509_certificate_.Add()->assign(value);
}
inline void PrincipleDescriptor::add_trusting_x509_certificate(const char* value) {
  trusting_x509_certificate_.Add()->assign(value);
}
inline void PrincipleDescriptor::add_trusting_x509_certificate(const char* value, size_t size) {
  trusting_x509_certificate_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// optional string encrypted_private_key = 6;
inline bool PrincipleDescriptor::has_encrypted_private_key() const {
  return _has_bit(4);
}
inline void PrincipleDescriptor::clear_encrypted_private_key() {
  if (encrypted_private_key_ != &_default_encrypted_private_key_) {
    encrypted_private_key_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& PrincipleDescriptor::encrypted_private_key() const {
  return *encrypted_private_key_;
}
inline void PrincipleDescriptor::set_encrypted_private_key(const ::std::string& value) {
  _set_bit(4);
  if (encrypted_private_key_ == &_default_encrypted_private_key_) {
    encrypted_private_key_ = new ::std::string;
  }
  encrypted_private_key_->assign(value);
}
inline void PrincipleDescriptor::set_encrypted_private_key(const char* value) {
  _set_bit(4);
  if (encrypted_private_key_ == &_default_encrypted_private_key_) {
    encrypted_private_key_ = new ::std::string;
  }
  encrypted_private_key_->assign(value);
}
inline void PrincipleDescriptor::set_encrypted_private_key(const char* value, size_t size) {
  _set_bit(4);
  if (encrypted_private_key_ == &_default_encrypted_private_key_) {
    encrypted_private_key_ = new ::std::string;
  }
  encrypted_private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PrincipleDescriptor::mutable_encrypted_private_key() {
  _set_bit(4);
  if (encrypted_private_key_ == &_default_encrypted_private_key_) {
    encrypted_private_key_ = new ::std::string;
  }
  return encrypted_private_key_;
}

// optional .larpc.EncryptionDescriptor private_key_encryption_descriptor = 7;
inline bool PrincipleDescriptor::has_private_key_encryption_descriptor() const {
  return _has_bit(5);
}
inline void PrincipleDescriptor::clear_private_key_encryption_descriptor() {
  if (private_key_encryption_descriptor_ != NULL) private_key_encryption_descriptor_->::larpc::EncryptionDescriptor::Clear();
  _clear_bit(5);
}
inline const ::larpc::EncryptionDescriptor& PrincipleDescriptor::private_key_encryption_descriptor() const {
  return private_key_encryption_descriptor_ != NULL ? *private_key_encryption_descriptor_ : *default_instance_->private_key_encryption_descriptor_;
}
inline ::larpc::EncryptionDescriptor* PrincipleDescriptor::mutable_private_key_encryption_descriptor() {
  _set_bit(5);
  if (private_key_encryption_descriptor_ == NULL) private_key_encryption_descriptor_ = new ::larpc::EncryptionDescriptor;
  return private_key_encryption_descriptor_;
}

// repeated .larpc.PrincipleVersionRecord past_versions = 8;
inline int PrincipleDescriptor::past_versions_size() const {
  return past_versions_.size();
}
inline void PrincipleDescriptor::clear_past_versions() {
  past_versions_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleVersionRecord >&
PrincipleDescriptor::past_versions() const {
  return past_versions_;
}
inline ::google::protobuf::RepeatedPtrField< ::larpc::PrincipleVersionRecord >*
PrincipleDescriptor::mutable_past_versions() {
  return &past_versions_;
}
inline const ::larpc::PrincipleVersionRecord& PrincipleDescriptor::past_versions(int index) const {
  return past_versions_.Get(index);
}
inline ::larpc::PrincipleVersionRecord* PrincipleDescriptor::mutable_past_versions(int index) {
  return past_versions_.Mutable(index);
}
inline ::larpc::PrincipleVersionRecord* PrincipleDescriptor::add_past_versions() {
  return past_versions_.Add();
}

// -------------------------------------------------------------------

// MethodDescriptor

// optional string method_name = 1;
inline bool MethodDescriptor::has_method_name() const {
  return _has_bit(0);
}
inline void MethodDescriptor::clear_method_name() {
  if (method_name_ != &_default_method_name_) {
    method_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& MethodDescriptor::method_name() const {
  return *method_name_;
}
inline void MethodDescriptor::set_method_name(const ::std::string& value) {
  _set_bit(0);
  if (method_name_ == &_default_method_name_) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void MethodDescriptor::set_method_name(const char* value) {
  _set_bit(0);
  if (method_name_ == &_default_method_name_) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(value);
}
inline void MethodDescriptor::set_method_name(const char* value, size_t size) {
  _set_bit(0);
  if (method_name_ == &_default_method_name_) {
    method_name_ = new ::std::string;
  }
  method_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MethodDescriptor::mutable_method_name() {
  _set_bit(0);
  if (method_name_ == &_default_method_name_) {
    method_name_ = new ::std::string;
  }
  return method_name_;
}

// -------------------------------------------------------------------

// RPCRequest

// optional string channel_id = 1;
inline bool RPCRequest::has_channel_id() const {
  return _has_bit(0);
}
inline void RPCRequest::clear_channel_id() {
  if (channel_id_ != &_default_channel_id_) {
    channel_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RPCRequest::channel_id() const {
  return *channel_id_;
}
inline void RPCRequest::set_channel_id(const ::std::string& value) {
  _set_bit(0);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void RPCRequest::set_channel_id(const char* value) {
  _set_bit(0);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void RPCRequest::set_channel_id(const char* value, size_t size) {
  _set_bit(0);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCRequest::mutable_channel_id() {
  _set_bit(0);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}

// optional uint32 request_id = 2;
inline bool RPCRequest::has_request_id() const {
  return _has_bit(1);
}
inline void RPCRequest::clear_request_id() {
  request_id_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 RPCRequest::request_id() const {
  return request_id_;
}
inline void RPCRequest::set_request_id(::google::protobuf::uint32 value) {
  _set_bit(1);
  request_id_ = value;
}

// optional .larpc.MethodDescriptor method_id = 3;
inline bool RPCRequest::has_method_id() const {
  return _has_bit(2);
}
inline void RPCRequest::clear_method_id() {
  if (method_id_ != NULL) method_id_->::larpc::MethodDescriptor::Clear();
  _clear_bit(2);
}
inline const ::larpc::MethodDescriptor& RPCRequest::method_id() const {
  return method_id_ != NULL ? *method_id_ : *default_instance_->method_id_;
}
inline ::larpc::MethodDescriptor* RPCRequest::mutable_method_id() {
  _set_bit(2);
  if (method_id_ == NULL) method_id_ = new ::larpc::MethodDescriptor;
  return method_id_;
}

// optional bytes method_parameters = 4;
inline bool RPCRequest::has_method_parameters() const {
  return _has_bit(3);
}
inline void RPCRequest::clear_method_parameters() {
  if (method_parameters_ != &_default_method_parameters_) {
    method_parameters_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& RPCRequest::method_parameters() const {
  return *method_parameters_;
}
inline void RPCRequest::set_method_parameters(const ::std::string& value) {
  _set_bit(3);
  if (method_parameters_ == &_default_method_parameters_) {
    method_parameters_ = new ::std::string;
  }
  method_parameters_->assign(value);
}
inline void RPCRequest::set_method_parameters(const char* value) {
  _set_bit(3);
  if (method_parameters_ == &_default_method_parameters_) {
    method_parameters_ = new ::std::string;
  }
  method_parameters_->assign(value);
}
inline void RPCRequest::set_method_parameters(const void* value, size_t size) {
  _set_bit(3);
  if (method_parameters_ == &_default_method_parameters_) {
    method_parameters_ = new ::std::string;
  }
  method_parameters_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCRequest::mutable_method_parameters() {
  _set_bit(3);
  if (method_parameters_ == &_default_method_parameters_) {
    method_parameters_ = new ::std::string;
  }
  return method_parameters_;
}

// -------------------------------------------------------------------

// RPCResponse

// optional string channel_id = 1;
inline bool RPCResponse::has_channel_id() const {
  return _has_bit(0);
}
inline void RPCResponse::clear_channel_id() {
  if (channel_id_ != &_default_channel_id_) {
    channel_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RPCResponse::channel_id() const {
  return *channel_id_;
}
inline void RPCResponse::set_channel_id(const ::std::string& value) {
  _set_bit(0);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void RPCResponse::set_channel_id(const char* value) {
  _set_bit(0);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void RPCResponse::set_channel_id(const char* value, size_t size) {
  _set_bit(0);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCResponse::mutable_channel_id() {
  _set_bit(0);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}

// optional uint32 request_id = 2;
inline bool RPCResponse::has_request_id() const {
  return _has_bit(1);
}
inline void RPCResponse::clear_request_id() {
  request_id_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 RPCResponse::request_id() const {
  return request_id_;
}
inline void RPCResponse::set_request_id(::google::protobuf::uint32 value) {
  _set_bit(1);
  request_id_ = value;
}

// optional bytes response = 3;
inline bool RPCResponse::has_response() const {
  return _has_bit(2);
}
inline void RPCResponse::clear_response() {
  if (response_ != &_default_response_) {
    response_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RPCResponse::response() const {
  return *response_;
}
inline void RPCResponse::set_response(const ::std::string& value) {
  _set_bit(2);
  if (response_ == &_default_response_) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RPCResponse::set_response(const char* value) {
  _set_bit(2);
  if (response_ == &_default_response_) {
    response_ = new ::std::string;
  }
  response_->assign(value);
}
inline void RPCResponse::set_response(const void* value, size_t size) {
  _set_bit(2);
  if (response_ == &_default_response_) {
    response_ = new ::std::string;
  }
  response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCResponse::mutable_response() {
  _set_bit(2);
  if (response_ == &_default_response_) {
    response_ = new ::std::string;
  }
  return response_;
}

// -------------------------------------------------------------------

// OpenChannelRequest

// optional bytes initiator_public_key = 1;
inline bool OpenChannelRequest::has_initiator_public_key() const {
  return _has_bit(0);
}
inline void OpenChannelRequest::clear_initiator_public_key() {
  if (initiator_public_key_ != &_default_initiator_public_key_) {
    initiator_public_key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OpenChannelRequest::initiator_public_key() const {
  return *initiator_public_key_;
}
inline void OpenChannelRequest::set_initiator_public_key(const ::std::string& value) {
  _set_bit(0);
  if (initiator_public_key_ == &_default_initiator_public_key_) {
    initiator_public_key_ = new ::std::string;
  }
  initiator_public_key_->assign(value);
}
inline void OpenChannelRequest::set_initiator_public_key(const char* value) {
  _set_bit(0);
  if (initiator_public_key_ == &_default_initiator_public_key_) {
    initiator_public_key_ = new ::std::string;
  }
  initiator_public_key_->assign(value);
}
inline void OpenChannelRequest::set_initiator_public_key(const void* value, size_t size) {
  _set_bit(0);
  if (initiator_public_key_ == &_default_initiator_public_key_) {
    initiator_public_key_ = new ::std::string;
  }
  initiator_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenChannelRequest::mutable_initiator_public_key() {
  _set_bit(0);
  if (initiator_public_key_ == &_default_initiator_public_key_) {
    initiator_public_key_ = new ::std::string;
  }
  return initiator_public_key_;
}

// optional bytes initiator_certificate = 2;
inline bool OpenChannelRequest::has_initiator_certificate() const {
  return _has_bit(1);
}
inline void OpenChannelRequest::clear_initiator_certificate() {
  if (initiator_certificate_ != &_default_initiator_certificate_) {
    initiator_certificate_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OpenChannelRequest::initiator_certificate() const {
  return *initiator_certificate_;
}
inline void OpenChannelRequest::set_initiator_certificate(const ::std::string& value) {
  _set_bit(1);
  if (initiator_certificate_ == &_default_initiator_certificate_) {
    initiator_certificate_ = new ::std::string;
  }
  initiator_certificate_->assign(value);
}
inline void OpenChannelRequest::set_initiator_certificate(const char* value) {
  _set_bit(1);
  if (initiator_certificate_ == &_default_initiator_certificate_) {
    initiator_certificate_ = new ::std::string;
  }
  initiator_certificate_->assign(value);
}
inline void OpenChannelRequest::set_initiator_certificate(const void* value, size_t size) {
  _set_bit(1);
  if (initiator_certificate_ == &_default_initiator_certificate_) {
    initiator_certificate_ = new ::std::string;
  }
  initiator_certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenChannelRequest::mutable_initiator_certificate() {
  _set_bit(1);
  if (initiator_certificate_ == &_default_initiator_certificate_) {
    initiator_certificate_ = new ::std::string;
  }
  return initiator_certificate_;
}

// optional .larpc.PrincipleDescriptor desired_principle = 3;
inline bool OpenChannelRequest::has_desired_principle() const {
  return _has_bit(2);
}
inline void OpenChannelRequest::clear_desired_principle() {
  if (desired_principle_ != NULL) desired_principle_->::larpc::PrincipleDescriptor::Clear();
  _clear_bit(2);
}
inline const ::larpc::PrincipleDescriptor& OpenChannelRequest::desired_principle() const {
  return desired_principle_ != NULL ? *desired_principle_ : *default_instance_->desired_principle_;
}
inline ::larpc::PrincipleDescriptor* OpenChannelRequest::mutable_desired_principle() {
  _set_bit(2);
  if (desired_principle_ == NULL) desired_principle_ = new ::larpc::PrincipleDescriptor;
  return desired_principle_;
}

// optional string channel_id = 4;
inline bool OpenChannelRequest::has_channel_id() const {
  return _has_bit(3);
}
inline void OpenChannelRequest::clear_channel_id() {
  if (channel_id_ != &_default_channel_id_) {
    channel_id_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& OpenChannelRequest::channel_id() const {
  return *channel_id_;
}
inline void OpenChannelRequest::set_channel_id(const ::std::string& value) {
  _set_bit(3);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void OpenChannelRequest::set_channel_id(const char* value) {
  _set_bit(3);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(value);
}
inline void OpenChannelRequest::set_channel_id(const char* value, size_t size) {
  _set_bit(3);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenChannelRequest::mutable_channel_id() {
  _set_bit(3);
  if (channel_id_ == &_default_channel_id_) {
    channel_id_ = new ::std::string;
  }
  return channel_id_;
}

// -------------------------------------------------------------------

// OpenChannelResponse

// optional string initiator_channel_id = 1;
inline bool OpenChannelResponse::has_initiator_channel_id() const {
  return _has_bit(0);
}
inline void OpenChannelResponse::clear_initiator_channel_id() {
  if (initiator_channel_id_ != &_default_initiator_channel_id_) {
    initiator_channel_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OpenChannelResponse::initiator_channel_id() const {
  return *initiator_channel_id_;
}
inline void OpenChannelResponse::set_initiator_channel_id(const ::std::string& value) {
  _set_bit(0);
  if (initiator_channel_id_ == &_default_initiator_channel_id_) {
    initiator_channel_id_ = new ::std::string;
  }
  initiator_channel_id_->assign(value);
}
inline void OpenChannelResponse::set_initiator_channel_id(const char* value) {
  _set_bit(0);
  if (initiator_channel_id_ == &_default_initiator_channel_id_) {
    initiator_channel_id_ = new ::std::string;
  }
  initiator_channel_id_->assign(value);
}
inline void OpenChannelResponse::set_initiator_channel_id(const char* value, size_t size) {
  _set_bit(0);
  if (initiator_channel_id_ == &_default_initiator_channel_id_) {
    initiator_channel_id_ = new ::std::string;
  }
  initiator_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenChannelResponse::mutable_initiator_channel_id() {
  _set_bit(0);
  if (initiator_channel_id_ == &_default_initiator_channel_id_) {
    initiator_channel_id_ = new ::std::string;
  }
  return initiator_channel_id_;
}

// optional string responding_channel_id = 2;
inline bool OpenChannelResponse::has_responding_channel_id() const {
  return _has_bit(1);
}
inline void OpenChannelResponse::clear_responding_channel_id() {
  if (responding_channel_id_ != &_default_responding_channel_id_) {
    responding_channel_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OpenChannelResponse::responding_channel_id() const {
  return *responding_channel_id_;
}
inline void OpenChannelResponse::set_responding_channel_id(const ::std::string& value) {
  _set_bit(1);
  if (responding_channel_id_ == &_default_responding_channel_id_) {
    responding_channel_id_ = new ::std::string;
  }
  responding_channel_id_->assign(value);
}
inline void OpenChannelResponse::set_responding_channel_id(const char* value) {
  _set_bit(1);
  if (responding_channel_id_ == &_default_responding_channel_id_) {
    responding_channel_id_ = new ::std::string;
  }
  responding_channel_id_->assign(value);
}
inline void OpenChannelResponse::set_responding_channel_id(const char* value, size_t size) {
  _set_bit(1);
  if (responding_channel_id_ == &_default_responding_channel_id_) {
    responding_channel_id_ = new ::std::string;
  }
  responding_channel_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenChannelResponse::mutable_responding_channel_id() {
  _set_bit(1);
  if (responding_channel_id_ == &_default_responding_channel_id_) {
    responding_channel_id_ = new ::std::string;
  }
  return responding_channel_id_;
}

// optional bytes responding_certificate = 3;
inline bool OpenChannelResponse::has_responding_certificate() const {
  return _has_bit(2);
}
inline void OpenChannelResponse::clear_responding_certificate() {
  if (responding_certificate_ != &_default_responding_certificate_) {
    responding_certificate_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& OpenChannelResponse::responding_certificate() const {
  return *responding_certificate_;
}
inline void OpenChannelResponse::set_responding_certificate(const ::std::string& value) {
  _set_bit(2);
  if (responding_certificate_ == &_default_responding_certificate_) {
    responding_certificate_ = new ::std::string;
  }
  responding_certificate_->assign(value);
}
inline void OpenChannelResponse::set_responding_certificate(const char* value) {
  _set_bit(2);
  if (responding_certificate_ == &_default_responding_certificate_) {
    responding_certificate_ = new ::std::string;
  }
  responding_certificate_->assign(value);
}
inline void OpenChannelResponse::set_responding_certificate(const void* value, size_t size) {
  _set_bit(2);
  if (responding_certificate_ == &_default_responding_certificate_) {
    responding_certificate_ = new ::std::string;
  }
  responding_certificate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenChannelResponse::mutable_responding_certificate() {
  _set_bit(2);
  if (responding_certificate_ == &_default_responding_certificate_) {
    responding_certificate_ = new ::std::string;
  }
  return responding_certificate_;
}

// -------------------------------------------------------------------

// ChannelControl

// repeated .larpc.OpenChannelRequest open_channel_request = 1;
inline int ChannelControl::open_channel_request_size() const {
  return open_channel_request_.size();
}
inline void ChannelControl::clear_open_channel_request() {
  open_channel_request_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelRequest >&
ChannelControl::open_channel_request() const {
  return open_channel_request_;
}
inline ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelRequest >*
ChannelControl::mutable_open_channel_request() {
  return &open_channel_request_;
}
inline const ::larpc::OpenChannelRequest& ChannelControl::open_channel_request(int index) const {
  return open_channel_request_.Get(index);
}
inline ::larpc::OpenChannelRequest* ChannelControl::mutable_open_channel_request(int index) {
  return open_channel_request_.Mutable(index);
}
inline ::larpc::OpenChannelRequest* ChannelControl::add_open_channel_request() {
  return open_channel_request_.Add();
}

// repeated .larpc.OpenChannelResponse open_channel_response = 2;
inline int ChannelControl::open_channel_response_size() const {
  return open_channel_response_.size();
}
inline void ChannelControl::clear_open_channel_response() {
  open_channel_response_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelResponse >&
ChannelControl::open_channel_response() const {
  return open_channel_response_;
}
inline ::google::protobuf::RepeatedPtrField< ::larpc::OpenChannelResponse >*
ChannelControl::mutable_open_channel_response() {
  return &open_channel_response_;
}
inline const ::larpc::OpenChannelResponse& ChannelControl::open_channel_response(int index) const {
  return open_channel_response_.Get(index);
}
inline ::larpc::OpenChannelResponse* ChannelControl::mutable_open_channel_response(int index) {
  return open_channel_response_.Mutable(index);
}
inline ::larpc::OpenChannelResponse* ChannelControl::add_open_channel_response() {
  return open_channel_response_.Add();
}

// repeated string close_channel_id = 3;
inline int ChannelControl::close_channel_id_size() const {
  return close_channel_id_.size();
}
inline void ChannelControl::clear_close_channel_id() {
  close_channel_id_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChannelControl::close_channel_id() const {
  return close_channel_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChannelControl::mutable_close_channel_id() {
  return &close_channel_id_;
}
inline const ::std::string& ChannelControl::close_channel_id(int index) const {
  return close_channel_id_.Get(index);
}
inline ::std::string* ChannelControl::mutable_close_channel_id(int index) {
  return close_channel_id_.Mutable(index);
}
inline void ChannelControl::set_close_channel_id(int index, const ::std::string& value) {
  close_channel_id_.Mutable(index)->assign(value);
}
inline void ChannelControl::set_close_channel_id(int index, const char* value) {
  close_channel_id_.Mutable(index)->assign(value);
}
inline void ChannelControl::set_close_channel_id(int index, const char* value, size_t size) {
  close_channel_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChannelControl::add_close_channel_id() {
  return close_channel_id_.Add();
}
inline void ChannelControl::add_close_channel_id(const ::std::string& value) {
  close_channel_id_.Add()->assign(value);
}
inline void ChannelControl::add_close_channel_id(const char* value) {
  close_channel_id_.Add()->assign(value);
}
inline void ChannelControl::add_close_channel_id(const char* value, size_t size) {
  close_channel_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
}


}  // namespace larpc

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_larpc_2eproto__INCLUDED
